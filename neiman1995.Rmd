---
title: "Visualizing Neimans 'Stylistic variation in evolutionary perspective'"
author: "Clemens Schmid"
date: "April 2018"
output: 
  html_document:
    css: styles.css
    toc: true
    toc_depth: 4
runtime: shiny
---

This document visualizes the general model functions in Fraser D. Neimans article *Stylistic Variation in Evolutionary Perspective: Inferences from Decorative Diversity and Interassemblage Distance in Illinois Woodland Ceramic Assemblages* from 1995. 

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = FALSE}
library(ggplot2)
library(magrittr)

source("./R/group_drift_simulation.R", local = TRUE)
source("./R/squared_euclidian_distance.R", local = TRUE)
source("./R/multi_group_matrix_calculation.R", local = TRUE)
```

### Drift, Innovation and Diversity

#### Temporal Dynamics of Drift *p.10*

- $k$: amount of variants
- $N$: population size
- $t$: time / number of iterations

```{r echo=FALSE}
inputPanel(
  sliderInput("k", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_final", label = "t",
             min = 50, max = 200, value = 100, step = 50),
  actionButton("run_button_drift_simulation", "Run simulation")
)

drift_simulation_plot <- eventReactive(
  input$run_button_drift_simulation, {
    k <- input$k
    N <- input$N
    t_final <- input$t_final
    
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:t_final
    
    pop0 <- tibble::tibble(
      time = as.integer(1),
      individual = 1:N,
      variant = rep_len(1:k, N)
    )
    
    pop_devel <- list()
    pop_devel[[1]] <- pop0
    
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]] 
      pop_new$time <- p1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
      pop_devel[[p1]] <- pop_new
    }
    
    pop_devel_df <- do.call(rbind, pop_devel)
    
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      # that's just to fil gaps in the area plot
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum %>%
      ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab("time / number of iterations") +
      ylab("variants and their occurence in the population [%]")
  },
  ignoreNULL = FALSE
)

renderPlot({
  drift_simulation_plot()
})
```

#### Homogeneity Under Drift *p.10-12* **(1)**

The amount of increase in homogeneity in each time period is inversely proportional to the effective population size.

$$F_t = \frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}$$

- $F_t$: within-population homogeneity (probability that two randomly chosen individuals in the population carry variants that are copies of a common antecedent variant) at a certain timestep
- $F_{t - 1}$: there is always a chance that this second individual's model learned from the same model as did the first individual's model in a still earlier time period
- $t$: time
- $N_e$: size of the effective population

```{r echo=FALSE}
Ft <- function(F0, Ne, t) {
  if(t == 0) {return(F0)}
  1/Ne + (1 - 1/Ne) * Ft(F0, Ne, t - 1)
}

inputPanel(
  sliderInput("F0", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne", label = "Ne",
               min = 10, max = 100, value = 20, step = 10)
)

renderPlot({
  this_t = 1:100
  this_Ft <- sapply(this_t, function(x) {Ft(input$F0, input$Ne, x)})
  
  data.frame(
    t = this_t,
    Ft <- this_Ft
  ) %>%
    ggplot() +
    geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_line(aes(t, Ft), size = 1) +
    theme_bw()
})
```

#### Temporal Dynamics of Drift and Innovation *p.12-14*

- $μ$: innovation rate

```{r echo=FALSE}
inputPanel(
  sliderInput("k_2", label = "k for t == 0",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_2", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_final_2", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_sim", label = "μ",
               min = 0, max = 0.1, value = 0.01, step = 0.01),
  actionButton("run_button_drift_simulation_innovation", "Run simulation")
)

drift_simulation_plot_2 <- eventReactive(
  input$run_button_drift_simulation_innovation, {
    k <- input$k_2
    N <- input$N_2
    t_final <- input$t_final_2
    mu_sim <- input$mu_sim
  
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:t_final
  
    pop0 <- tibble::tibble(
      time = as.integer(1),
      individual = 1:N,
      variant = rep_len(1:k, N)
    )
  
    pop_devel <- list()
    pop_devel[[1]] <- pop0
  
    last_variant <- max(pop_devel[[1]]$variant)
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]]
      pop_new$time <- p1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
  
      # innovation
      innovate_here <- sample(
        c(TRUE, FALSE), 
        length(pop_new$variant), 
        prob = c(mu_sim, 1 - mu_sim), 
        replace = T
      )
      new_variants <- seq(last_variant + 1, last_variant + sum(innovate_here))
      last_variant <- last_variant + sum(innovate_here)
      pop_new$variant[innovate_here] <- new_variants
  
      pop_devel[[p1]] <- pop_new
    }
  
    pop_devel_df <- do.call(rbind, pop_devel)
  
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      # that's just to fil gaps in the area plot
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
  
    pop_devel_sum %>%
      ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab("time / number of iterations") +
      ylab("variants and their occurence in the population [%]")
  },
  ignoreNULL = FALSE
)

renderPlot({
  drift_simulation_plot_2()
})
```

#### Homogeneity Under Drift and Innovation *p.14* **(2)** **(3)** **(4)** **(5)**

$$F_t = \left(\frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}\right)(1 - μ)^2$$

```{r echo=FALSE}
Ft_2 <- function(F0, Ne, t, mu) {
  if(t == 0) {return(F0)}
  (1/Ne + (1 - 1/Ne) * Ft_2(F0, Ne, t - 1, mu)) * (1 - mu)^2
}

inputPanel(
  sliderInput("F0_2", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_2", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_2", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderPlot({
  this_t_2 = 1:100
  this_Ft_2 <- sapply(this_t_2, function(x) {Ft_2(input$F0_2, input$Ne_2, x, input$mu_2)})
  
  data.frame(
    t = this_t_2,
    Ft <- this_Ft_2
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_line(aes(t, Ft), size = 1) +
    theme_bw()
})
```

$$\hat{F} = \frac{(1 - μ)^2}{N_e} - (N_e - 1)(1 - μ)^2$$

$$\hat{F} \simeq \frac{1}{2 N_e μ + 1}$$

- $θ$: $2*N_e*μ$ 

The homogeneity of neutral variants within a population is inversely proportional to twice the effective population size times the innovation rate.

```{r echo=FALSE}
theta <- function(Ne, mu) {
  (2 * Ne * mu)
}

Fhat <- function(theta) {
  1 / (theta + 1)
}

inputPanel(
  sliderInput("Ne_3", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_3", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_3, input$mu_3))
})

renderPlot({
  theta = 0:100 * theta(input$Ne_3, input$mu_3)
  this_Fhat <- sapply(theta, function(x) {Fhat(x)})
  
  data.frame(
    t = theta,
    Fhat <- this_Fhat
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_line(aes(theta, Fhat), size = 1) +
    theme_bw() +
    xlab("x * theta")
})
```

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

- $p_i$: relative frequency of the i'th variant in the population 

```{r echo=FALSE}
Fhat_2 <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  sum(p^2)
}

renderPlot({
  tibble::tibble(
    amount_of_variants = 0:100,
    Fhat_min = sapply(amount_of_variants, function(x) {
      min(replicate(500, Fhat_2(x)))
    }),
    Fhat_max = sapply(amount_of_variants, function(x) {
      max(replicate(500, Fhat_2(x)))
    }),
    Fhat_mean = (Fhat_min + Fhat_max) / 2
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_ribbon(
      aes(x = amount_of_variants, ymin = Fhat_min, ymax = Fhat_max), 
      fill = "deepskyblue", alpha = 0.5
    ) +
    geom_line(aes(x = amount_of_variants, y = Fhat_mean), color = "black", size = 1) +
    theme_bw()
})
```

#### Diversity *p.14-15* **(6)** **(7)**

Estimating diversity within a population in these terms means that the population contains the same amount of diversity as would be found in an imaginary population with the effective number of variants at equal frequency.

$$n_e = 2 N_e μ + 1$$

- $n_e$ = Effective number of variants

```{r echo=FALSE}
ne <- function(theta) {
  theta + 1
}

inputPanel(
  sliderInput("Ne_4", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_4", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_4, input$mu_4))
})

renderPlot({
  tibble::tibble(
    theta = 0:100 * theta(input$Ne_4, input$mu_4),
    ne = sapply(theta, function(x) {ne(x)})
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_line(aes(theta, ne), size = 1) +
    theme_bw() +
    xlab("x * theta")
})
```

Furthermore, it is clear that θ can be estimated empirically by computing the reciprocal of the sum of squares of variant frequencies in a population.

$$t_F = \frac{1}{\sum_{i=1}^{k} p^2_i} - 1$$

- $t_F$: Estimated θ by the sum of squares of variant frequencies

```{r echo=FALSE}
theta_F <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  (1 / sum(p^2)) - 1
}

renderPlot({
  tibble::tibble(
    amount_of_variants = 0:100,
    theta_F_min = sapply(amount_of_variants, function(x) {
      min(replicate(500, theta_F(x)))
    }),
    theta_F_max = sapply(amount_of_variants, function(x) {
      max(replicate(500, theta_F(x)))
    }),
    theta_F_mean = (theta_F_min + theta_F_max) / 2
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_ribbon(
      aes(x = amount_of_variants, ymin = theta_F_min, ymax = theta_F_max), 
      fill = "deepskyblue", alpha = 0.5
    ) +
    geom_line(aes(x = amount_of_variants, y = theta_F_mean), size = 1) +
    theme_bw()
})
```

### Archaeological Application

#### Diversity and Sample Size *p.15-16* **(8)** **(9)**

$$H = -\sum_{i = 1}^{k} p_i \log(p_i)$$

- $H$: [Shannon's diversity index](http://www.tiem.utk.edu/~gross/bioed/bealsmodules/shannonDI.html)

```{r echo=FALSE}
H <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  -sum(p * log(p))
}

renderPlot({
  tibble::tibble(
    amount_of_variants = 0:100,
    H_min = sapply(amount_of_variants, function(x) {
      min(replicate(500, H(x)))
    }),
    H_max = sapply(amount_of_variants, function(x) {
      max(replicate(500, H(x)))
    }),
    H_mean = (H_min + H_max) / 2
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_ribbon(
      aes(x = amount_of_variants, ymin = H_min, ymax = H_max), 
      fill = "deepskyblue", alpha = 0.5
    ) +
    geom_line(aes(x = amount_of_variants, y = H_mean), color = "black", size = 1) +
    theme_bw()
})
```

$$E(k) = \sum_{i = 0}^{n - 1} \frac{θ}{θ + i}$$

- $E(k)$: Expected number of different variants
- $n$: Sample size

```{r echo=FALSE}
Ek <- function(n, theta) {
  ressum <- 0
  for (i in 0:(n-1)) {
    ressum = ressum + (theta / (theta + i))
  }
  return(ressum)
}

inputPanel(
  sliderInput("Ne_5", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_ewens", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01),
  sliderInput("n_ewens", label = "n",
               min = 0, max = 100, value = 10, step = 1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_5, input$mu_ewens))
})

renderPlot({
  Ne <- input$Ne_5
  mu <- input$mu_ewens
  n <- input$n_ewens
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    n = rep(n, 101),
    Ek = purrr::map2_dbl(n, theta, function(a, b) {Ek(a, b)})
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_line(aes(theta, Ek), size = 1) +
    theme_bw() +
    xlab("x * theta")
})
```

### Drift, Intergroup Transmission, and Interassemblage Distance 

#### Dynamics of Stylistic Distance between Two Groups *p.21-24* **(10)**

$$d_{ij}^2 = \sum_{k = 1}^{n} (p_{ik} - p_{jk})^2$$

- $d_{ij}^2$: Squared Euclidian distance between to groups
- $n$: amount_of_variants

```{r echo=FALSE}
renderPlot({
  tibble::tibble(
    amount_of_variants = 0:100,
    sed_min = sapply(amount_of_variants, function(x) {
      min(replicate(500, sed(runif(x), runif(x))))
    }),
    sed_max = sapply(amount_of_variants, function(x) {
      max(replicate(500, sed(runif(x), runif(x))))
    }),
    sed_mean = (sed_min + sed_max) / 2
  ) %>%
    ggplot() +    
    geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_ribbon(
      aes(x = amount_of_variants, ymin = sed_min, ymax = sed_max), 
      fill = "deepskyblue", alpha = 0.5
    ) +
    geom_line(aes(x = amount_of_variants, y = sed_mean), color = "black", size = 1) +
    theme_bw()
})
```

Simulation

$m_i$: intergroup transmission rate

```{r echo=FALSE}
inputPanel(
  sliderInput("k_group", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_group", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_final_group", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mi", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  actionButton("run_button_group_drift_simulation", "Run simulation")
)

group_drift_simulation_data <- eventReactive(
  input$run_button_group_drift_simulation, {
    group_drift_simulation(
      input$k_group, 
      input$N_group, 
      input$t_final_group, 
      input$mi
    )
  },
  ignoreNULL = FALSE
)

renderPlot({
  group_drift_simulation_data() %>%
    ggplot() +
    geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
    geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
    theme_bw() +
    xlab("time / number of iterations") +
    ylab("variants and their occurence in the population [%]") +
    facet_grid(group ~ .)
})
```

```{r echo=FALSE}
renderPlot({
  calculate_sed_for_group_drift_simulation_result(
    group_drift_simulation_data()
  ) %>%
    ggplot() +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
    geom_line(aes(x = t, y = sed), color = "black", size = 1, alpha = 0.3) +
    geom_point(aes(x = t, y = sed), color = "black", size = 1) +
    theme_bw()
})
```

Many simulation runs

```{r echo=FALSE}
inputPanel(
  sliderInput("k_group_2", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_group_2", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_final_group_2", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_2", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_group_drift_simulation_iter", "Run simulation")
)

group_drift_simulation_data_2 <- eventReactive(
  input$run_button_group_drift_simulation_iter, {
    
    res_list <- list()
    for (i in 1:input$sim_runs) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          input$k_group_2, 
          input$N_group_2, 
          input$t_final_group_2, 
          input$mi_2
        ),
        sim_run = i
      ) 
    }
    
    do.call(rbind, res_list) %>%
      ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed, group = sim_run), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw()
  },
  ignoreNULL = FALSE
)

renderPlot({
  group_drift_simulation_data_2()
})
```

#### Stylistic Distances for Multiple Groups *p.24-25* **(11)**

$$\mathbf{V}^{(t)} = \sum_{r = 0}^{t - 1} \mathbf{M}^r \mathbf{U}(\mathbf{M}^r)^{\prime}$$

- $\mathbf{M}$: Matrix of intergroup transmission rates
- $\mathbf{V}^{(t)}$: Matrix of variances and covariances
- $r$: Index of the successive time periods
- $\mathbf{U}$ Matrix of reciprocals of the effective population sizes ($1 / N_e$). These are on the diagonal, the rest is 0.
- $(\mathbf{M}^r)^{\prime}$: M transponiert

```{r echo = FALSE}
inputPanel(
  sliderInput("Ne_matrix", label = "Ne",
             min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_matrix", label = "t",
             min = 10, max = 100, value = 20, step = 10),
  actionButton("run_button_matrix_calculation", "Run matrix calculation")
)

matrix_calculation_data <- eventReactive(
  input$run_button_matrix_calculation, {
    multi_group_matrizes(input$Ne_matrix, input$t_matrix)
  },
  ignoreNULL = FALSE
)

renderPlot({
  Mplot <- ggplot(matrix_calculation_data()$longM, aes(x = Var2, y = Var1)) + 
    geom_raster(aes(fill=value)) +
    geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
    scale_y_reverse(sec.axis = dup_axis()) +
    scale_x_continuous(sec.axis = dup_axis())
  Mtplot <- ggplot(matrix_calculation_data()$longMt, aes(x = Var2, y = Var1)) + 
    geom_raster(aes(fill=value)) +
    geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
    scale_y_reverse(sec.axis = dup_axis()) +
    scale_x_continuous(sec.axis = dup_axis())
  Uplot <- ggplot(matrix_calculation_data()$longU, aes(x = Var2, y = Var1)) + 
    geom_raster(aes(fill=value)) +
    geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
    scale_y_reverse(sec.axis = dup_axis()) +
    scale_x_continuous(sec.axis = dup_axis())
  Vplot <- ggplot(matrix_calculation_data()$longV, aes(x = Var2, y = Var1)) + 
    geom_raster(aes(fill=value)) +
    geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
    scale_y_reverse(sec.axis = dup_axis()) +
    scale_x_continuous(sec.axis = dup_axis())
  mosedplot <- ggplot(matrix_calculation_data()$longmosed, aes(x = Var2, y = Var1)) + 
    geom_raster(aes(fill=value)) +
    geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
    scale_y_reverse(sec.axis = dup_axis()) +
    scale_x_continuous(sec.axis = dup_axis())
  msdplot <- ggplot(matrix_calculation_data()$longmsd, aes(x = Var2, y = Var1)) + 
    geom_raster(aes(fill=value)) +
    geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
    scale_y_reverse(sec.axis = dup_axis()) +
    scale_x_continuous(sec.axis = dup_axis())
  
  cowplot::plot_grid(
    Mplot, Mtplot, Uplot, Vplot, mosedplot, msdplot,
    labels = c("M", "M'", "U", "V", "SED", "MSD"), 
    nrow = 3, ncol = 2
  )
},
height = 1200
)
``` 

$$d_{ij}^{2(t)} = v_{ii}^{(t)} + v_{jj}^{(t)} - 2 v_{ij}^{(t)}$$

- $v_{ii}^{(t)}$: Diagonal element of $\mathbf{V}^{(t)}$ -- a variance. The square of of the departure of the variant frequency in the $i$'th deme at time $t$ from its starting frequency when the demes were identical, standardized by the variance of that starting frequency.
- $v_{ij}^{(t)}$: Covariance. The product of the departures of the variant frequencies in each pair of demes i and j, again standardized by the variance of the starting frequency. 


### Woodland Interassemblage Distance

#### Diversity and Distance for Individual Assemblages *p.26-27* **(12)**

$$\bar{d}_{i}^{2} = \sum_{j = 1}^{n} d_{ij}^{2} / (n - 1), i \neq j$$


