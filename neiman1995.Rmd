---
title: "Visualizing Neimans 'Stylistic variation in evolutionary perspective'"
author: "Clemens Schmid"
date: "April 2018"
output: 
  html_document:
    css: styles.css
    toc: true
    toc_depth: 4
runtime: shiny
bibliography: references.bib
link-citations: true
---

```{r include=FALSE}
# knitr chunk settings
knitr::opts_chunk$set(echo = TRUE)
```

This document visualizes the simulations and the general model functions in Fraser D. Neimans article *Stylistic Variation in Evolutionary Perspective: Inferences from Decorative Diversity and Interassemblage Distance in Illinois Woodland Ceramic Assemblages* [@neiman_stylistic_1995].

It mirrors the structure of the article and should be read in conjunction with it. It can be used to deepen the understanding of the complex variable relations, but it doesn't attempt to retell the story: the case study about woodland pottery isn't relevant here. The small descriptive texts are compiled from the article and also contain sentences copied verbatimly. I focused on the segments and explanations I considered most important for understanding the models and parameters. This document does not attempt to reach the threshold of orginality but is meant as a mere tool for learning and teaching.

```{r echo = FALSE}
# load the packages, that are inconvinient to reference directly via namespace::
library(ggplot2)
library(magrittr)
suppressMessages(library(expm))
# load the functions in the source files
purrr::walk(list.files("./R", full.names = T), function(x) {source(x)})
```

### Drift, Innovation and Diversity

#### Temporal Dynamics of Drift *p.10*

Minimal simulation of drift in a population of $N$ individuals with $k$ variants over $t$ timesteps. Drift is sampling error that accompanies all forms of cultural transmission and causes individual variants to vanish or dominate randomly. It causes one variant to dominate and eradicate all the others. The speed with which the variation is destroyed increases as the population size decreases.  

Mechanics of the simulation: In each timestep every individual randomly adopts a variant from somebody else. The probability of getting somebody elses variant is $(N - 1) / N$ while the probability of keeping the own variant is only $1 / N$. 

- $k$: Amount of variants in a population
- $N_e$: Size of the effective population. The effective population consists of the individuals within a population that is activly involved in a cultural transmission process
- $t$: Time / number of iterations

```{r echo=FALSE}
inputPanel(
  sliderInput("k_drift_simulation", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("Ne_drift_simulation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_drift_simulation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  actionButton("run_button_drift_simulation", "Run simulation")
)

drift_simulation_data <- eventReactive(
  input$run_button_drift_simulation, {
    
    # read input
    k <- input$k_drift_simulation
    N <- input$Ne_drift_simulation
    time <- input$t_drift_simulation
    
    # calculate population parameters
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:time
    
    # create initial population
    pop0 <- tibble::tibble(
      time = as.integer(0),
      individual = 1:N,
      variant = rep_len(1:k, N)
    )
    
    # list to store population stages over time
    pop_devel <- list()
    pop_devel[[1]] <- pop0
    
    # simulation loop
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]] 
      pop_new$time <- p1 - 1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
      pop_devel[[p1]] <- pop_new
    }
    
    # bind individual population stages into data.frame
    pop_devel_df <- do.call(rbind, pop_devel)
    
    # calculate number of individuals per timestep and variant
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      # complete (expand.grid) to fill gaps in the area plot
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum
  },
  ignoreNULL = FALSE
)

renderPlot({
  
  drift_simulation_data() %>%
    ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab(expression(paste("t"))) +
      ylab("variants and their occurence in the population [%]")
  
})
```

#### Homogeneity Under Drift *p.10-12* **(1)**

The theory of neutral alleles allows to describe the within-population homogeneity $F$ as a function of the effective population size $N_e$. $F$ is the probability that two randomly chosen individuals in the population carry variants that are copies of a common antecedent variant. In a given time period the probability of drawing an individual, who learned from the same model as some other randomly selected individual in the previous time period, is $1 / N$. The probability of the opposite is $1 - (1 / N)$. $F_{t - 1}$ is the probability that the model of the second individual learned from the same model as the model of the first individual in an earlier timestep. $F_t$ can be calculated by taking all this probabilities into consideration.  

$$F_t = \frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}$$

As an effect of drift, $F_t$ approaches one as $t$ increases.

- $F_t$: Within-population homogeneity. That's the probability that two randomly chosen individuals in the population carry variants that are copies of a common antecedent variant at a certain timestep
- $F_{t - 1}$: Probability that the model of the second individual learned from the same model as the model of the first indivudual in an earlier timestep

```{r echo=FALSE}
Ft <- function(F0, Ne, time) {
  if(time == 0) { return(F0) }
  1/Ne + (1 - 1/Ne) * Ft(F0, Ne, time - 1)
}

inputPanel(
  sliderInput("F0_homogeneity_drift", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_homogeneity_drift", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_homogeneity_drift", label = "t",
               min = 50, max = 200, value = 100, step = 50)
)

renderPlot({
  
  # read input
  F0 <- input$F0_homogeneity_drift
  Ne <- input$Ne_homogeneity_drift
  time <- input$t_homogeneity_drift
  
  timesteps <- 0:time
  
  # apply function for all timesteps
  Ft_time <- sapply(timesteps, function(x) { Ft(F0, Ne, x) })
  
  data.frame(
    t = timesteps,
    Ft = Ft_time
  ) %>%
    ggplot() +
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(t, Ft), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("F_{t}"))
})
```

#### Temporal Dynamics of Drift and Innovation *p.12-14*

Simulation built on the first simple drift simulation. Here the concept of innovation is added: Individuals can not just inherit but also create new variants with the probability $μ$. In this context $k$ is just the initial number of variants at $t = 0$. The effect of drift is still strongly visible, but with increasing $μ$ it becomes less relevant. New variants can form and replace the dominant one. 

Mechanics of the simulation: The simulation works like the first one, but now there's a chance of $μ$ for every indivual in every timestep to create a new variant.

- $μ$: Innovation rate. Probability of the creation of a new variant

```{r echo=FALSE}
inputPanel(
  sliderInput("k_drift_simulation_with_innovation", label = "k for t == 0",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("Ne_drift_simulation_with_innovation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_drift_simulation_with_innovation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_drift_simulation_with_innovation", label = "μ",
               min = 0, max = 0.1, value = 0.01, step = 0.01),
  actionButton("run_button_drift_simulation_with_innovation", "Run simulation")
)

drift_simulation_with_innovation_data <- eventReactive(
  input$run_button_drift_simulation_with_innovation, {
    
    # read input
    k <- input$k_drift_simulation_with_innovation
    N <- input$Ne_drift_simulation_with_innovation
    time <- input$t_drift_simulation_with_innovation
    mu <- input$mu_drift_simulation_with_innovation
  
    # prepare population parameters
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:time
  
    # create starting population
    pop0 <- tibble::tibble(
      time = as.integer(0),
      individual = 1:N,
      variant = rep_len(1:k, N)
    )
  
    # list to store population stages over time
    pop_devel <- list()
    pop_devel[[1]] <- pop0
  
    # simulation loop
    last_variant <- max(pop_devel[[1]]$variant)
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]]
      pop_new$time <- p1 - 1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
  
      # innovation
      innovate_here <- sample(
        c(TRUE, FALSE), 
        length(pop_new$variant), 
        prob = c(mu, 1 - mu), 
        replace = T
      )
      new_variants <- seq(last_variant + 1, last_variant + sum(innovate_here))
      last_variant <- last_variant + sum(innovate_here)
      pop_new$variant[innovate_here] <- new_variants
  
      pop_devel[[p1]] <- pop_new
    }
  
    # bind individual population stages into data.frame
    pop_devel_df <- do.call(rbind, pop_devel)
    
    # calculate number of individuals per timestep and variant
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum
  
  },
  ignoreNULL = FALSE
)

renderPlot({
  drift_simulation_with_innovation_data() %>%
    ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab("t") +
      ylab("variants and their occurence in the population [%]")
})
```

#### Homogeneity Under Drift and Innovation *p.14* **(2)** **(3)** **(4)** **(5)**

Drift and innovation are opposing forces: drift increases homogeneity and innovation decreases it. This causes an equilibrium after some timesteps in the simulation. We can incorporate innovation into the calculation of $F$ by modifying equation (1). If innovation is possible, $F$ is not just defined as learning from yourself or learning from somebody else: there's also the possibility to create a new variant. 

$$F_t = \left(\frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}\right)(1 - μ)^2$$

```{r echo=FALSE}
Ft_innovation <- function(F0, Ne, time, mu) {
  if(time == 0) {return(F0)}
  (1/Ne + (1 - 1/Ne) * Ft_innovation(F0, Ne, time - 1, mu)) * (1 - mu)^2
}

inputPanel(
  sliderInput("F0_homogeneity_drift_with_innovation", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_homogeneity_drift_with_innovation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_homogeneity_drift_with_innovation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_homogeneity_drift_with_innovation", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderPlot({
  
  # read input
  F0 <- input$F0_homogeneity_drift_with_innovation
  Ne <- input$Ne_homogeneity_drift_with_innovation
  mu <- input$mu_homogeneity_drift_with_innovation
  time <- input$t_homogeneity_drift_with_innovation
  
  timesteps <- 0:time
  
  # apply function for every timestep
  Ft_innovation_time <- sapply(timesteps, function(x) {Ft_innovation(F0, Ne, x, mu)})
  
  data.frame(
    t = timesteps,
    Ft = Ft_innovation_time
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(t, Ft), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("F_{t}"))
})
```

The equilibrium is reached, when $F_t = F_{t-1}$. Setting $F_t = F_{t-1}$ in equation (2) defines $\hat{F}$.

$$\hat{F} = \frac{(1 - μ)^2}{N_e} - (N_e - 1)(1 - μ)^2$$

If we assume $μ$ is quite small we can further simplify this definition.

$$\hat{F} \simeq \frac{1}{2 N_e μ + 1}$$

That means the homogeneity of neutral variants within a population is inversely proportional to twice the effective population size times the innovation rate: $2*N_e*μ$. This expression will be called $θ$.

- $θ$: Twice the effective population size times the innovation rate ($2 N_e μ$)

```{r echo=FALSE}
theta <- function(Ne, mu) {
  (2 * Ne * mu)
}

Fhat <- function(theta) {
  1 / (theta + 1)
}

inputPanel(
  sliderInput("Ne_homogeneity_equilibrium", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_homogeneity_equilibrium", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_homogeneity_equilibrium, input$mu_homogeneity_equilibrium))
})

renderPlot({
  Ne <- input$Ne_homogeneity_equilibrium
  mu <- input$mu_homogeneity_equilibrium
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    Fhat = sapply(theta, function(x) {Fhat(x)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, Fhat), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("\\hat{F}"))
})
```

The homogeneity $\hat{F}$ of a population can also be described as a function of the relative frequency of the variants in it: $p$. $p_i$ is the relative frequency of the $i$'th variant in the population, so $p$ is a vector of frequencies with the sum one. The probability of choosing a given variant at random is its relative frequency $p_i$, which is also the probability of picking another copy of this same variant on the second try. The probability of getting this variant twice in a row is therefore $p_i^2$. The total probability of getting any of the $i = 1$ to $k$ variants twice in a row is the sum of all these probabilities.

For this plot $p$ is randomly drawn some hundred times from a uniform distribution for every value of $k$. The black line shows the mean result for $\hat{F}$ the ribbon the min and max results.

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

- $p_i$: relative frequency of the i'th variant in the population 

```{r echo=FALSE}
Fhat_relative_frequency <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  sum(p^2)
}

inputPanel(
  sliderInput("k_relative_frequency", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_relative_frequency", label = "Number of random creations of p",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_relative_frequency", "Run simulation")
)

relative_frequency_data <- eventReactive(
  input$run_button_relative_frequency, {
  
    # read input  
    number_of_replications <- input$number_of_replications_relative_frequency
    k <- input$k_relative_frequency
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      Fhat_min = sapply(k, function(x) {
        min(replicate(number_of_replications, Fhat_relative_frequency(x)))
      }),
      Fhat_max = sapply(k, function(x) {
        max(replicate(number_of_replications, Fhat_relative_frequency(x)))
      }),
      Fhat_mean = (Fhat_min + Fhat_max) / 2
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  relative_frequency_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = Fhat_min, ymax = Fhat_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = Fhat_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("\\hat{F}"))
})
```

#### Diversity *p.14-15* **(6)** **(7)**

Instead of looking at homogeneity we can also estimate the diversity inside a population. One measure of diversity is the "effective number" of variants $n_e$, which is the reciprocal of $\hat{F}$. Estimating diversity within a population in these terms means that the population contains the same amount of diversity as would be found in an imaginary population with the effective number of variants at equal frequency. $n_e$ scales linearly with $θ$. Larger populations contain more diversity at a given level of innovation. Greater diversity is also expected in populations into which new variants are being introduced at higher rates. 

$$n_e = 2 N_e μ + 1$$

- $n_e$: Effective number of variants

```{r echo=FALSE}
ne <- function(theta) {
  theta + 1
}

inputPanel(
  sliderInput("Ne_diversity_effective_number", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_diversity_effective_number", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_diversity_effective_number, input$mu_diversity_effective_number))
})

renderPlot({
  
  # read input
  Ne <- input$Ne_diversity_effective_number
  mu <- input$mu_diversity_effective_number  
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    ne = sapply(theta, function(x) {ne(x)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, ne), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("n_e"))
})
```

Furthermore, it is clear that $θ$ can be estimated empirically by computing the reciprocal of the sum of squares of variant frequencies in a population. We can call such estimates $t_F$, to distinguish them from the actual population values and to remind ourselves they are based on homogeneity $\hat{F}$ in Equation (5). With this equation we can get useful insights into variations in $θ$ among groups or demes.

For this plot $p$ is randomly drawn some hundred times from a uniform distribution for every value of $k$. The black line shows the mean result for $t_F$ the ribbon the min and max results.

$$t_F = \frac{1}{\sum_{i=1}^{k} p^2_i} - 1$$

- $t_F$: Estimated $θ$ by the sum of squares of variant frequencies

```{r echo=FALSE}
theta_F <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  (1 / sum(p^2)) - 1
}

inputPanel(
  sliderInput("k_reciprocal_relative_frequency", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_reciprocal_relative_frequency", label = "Number of random creations of p",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_reciprocal_relative_frequency", "Run simulation")
)

reciprocal_relative_frequency_data <- eventReactive(
  input$run_button_reciprocal_relative_frequency, {
  
    # read input  
    number_of_replications <- input$number_of_replications_reciprocal_relative_frequency
    k <- input$k_reciprocal_relative_frequency
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      theta_F_min = sapply(k, function(x) {
        min(replicate(number_of_replications, theta_F(x)))
      }),
      theta_F_max = sapply(k, function(x) {
        max(replicate(number_of_replications, theta_F(x)))
      }),
      theta_F_mean = (theta_F_min + theta_F_max) / 2
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  reciprocal_relative_frequency_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = theta_F_min, ymax = theta_F_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = theta_F_mean), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("t_F"))
})
```

### Archaeological Application

#### Diversity and Sample Size *p.15-16* **(8)** **(9)**

One problem of the set of equations so far is that the frequency of variants in a population of social learners is not equal to the frequency preserved and documented in the archaeological assemblage. Under appropriate taphonomic circumstances, however, they are surprisingly similar. Another problem arises because we try to estimate diversity only on the basis of a sample derived from a population. The equations (5) and (7) are similar to the Shannon-Weaver information statistic, which is very senstitive to sample-size variation.

$$H = -\sum_{i = 1}^{k} p_i \log(p_i)$$

- $H$: [Shannon's diversity index](http://www.tiem.utk.edu/~gross/bioed/bealsmodules/shannonDI.html)

```{r echo=FALSE}
H <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  -sum(p * log(p))
}

inputPanel(
  sliderInput("k_shannon", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_shannon", label = "Number of random creations of p",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_shannon", "Run simulation")
)

shannon_data <- eventReactive(
  input$run_button_shannon, {
  
    # read input  
    number_of_replications <- input$number_of_replications_shannon
    k <- input$k_shannon
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      H_min = sapply(k, function(x) {
        min(replicate(number_of_replications, H(x)))
      }),
      H_max = sapply(k, function(x) {
        max(replicate(number_of_replications, H(x)))
      }),
      H_mean = (H_min + H_max) / 2
    ) 
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  shannon_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = H_min, ymax = H_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = H_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("H"))
})
```

To deal with the problem of sample-size dependency in the calculation of $t_F$ with equation (7), we have to consider that $θ$ also controls a characteristic probability distribution of variants. (7) shows how $θ$ is related to the sum of squared variant frequencies in a population, so it should be possible to predict for a given value of $θ$ how many variants occur with certain frequencies. When $θ$ is low ($θ \ll 1$), we should expect that most of the time , a population will be dominated by a few variants, with other variants at low frequencies. When $θ$ is high ($θ \gg 1$), we are more likely to see a large number of variants at low to moderate frequencies. 

By combining this frequency distribution with the probability that a variant at a given frequency is represented at least once in a sample of a given size drawn at random from the population, it should be possible to deduce how many different variants we can expect to find in a sample of a given size. If the variants are selectively neutral, the expected number of different variants $k$ found in a sample drawn from a population is a function of the sample size $n$ and the $θ$. The number of variants will be larger when either $θ$ or $n$ are large.

$$E(k) = \sum_{i = 0}^{n - 1} \frac{θ}{θ + i}$$

- $E(k)$: Expected number of different variants
- $n$: Sample size

```{r echo=FALSE}
Ek <- function(n, theta) {
  ressum <- 0
  for (i in 0:(n-1)) {
    ressum = ressum + (theta / (theta + i))
  }
  return(ressum)
}

inputPanel(
  sliderInput("Ne_expected_variants", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_expected_variants", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01),
  sliderInput("n_expected_variants", label = "n",
               min = 0, max = 100, value = 10, step = 1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_expected_variants, input$mu_expected_variants))
})

renderPlot({
  
  # read input
  Ne <- input$Ne_expected_variants
  mu <- input$mu_expected_variants
  n <- input$n_expected_variants
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    n = rep(n, 101),
    Ek = purrr::map2_dbl(n, theta, function(a, b) {Ek(a, b)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, Ek), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("E(k)"))
})
```

Equation (9) could be used to produce a maximum likelihood estimate of $θ$, that is the value of $θ$ that maximizes the chances of drawing the observed number of variants $k$ in a sample of the size $n$. Unfortunately it doesn't have an analytic solution, but we can still use it to estimate $θ$ iterativly by changing its value until $E(k)$ equals the observed number of variants. We call the result of doing so $t_E$. Both $t_E$ and $t_F$ offer us special statistical summaries of assemblage diversity, but there are theoretical reasons to prefer $t_E$ if $n$ and $k$ (and not just $p$) are known. 

This applet allows to solve (9) for theta approximately. It starts at $θ = 10$, changes it in steps of $0.1$ and stops when $|E(k) - k| < 0.5$.

```{r echo=FALSE}
inputPanel(
  sliderInput("n_iterative_theta", label = "n",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("k_iterative_theta", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  actionButton("run_iterative_theta", "Approximate theta")
)

iterative_theta_data <- eventReactive(
  input$run_iterative_theta, {
  
    # read input
    n <- input$n_iterative_theta
    k <- input$k_iterative_theta
    start_theta <- 10
    
    # iterative solving loop
    theta_iter <- start_theta
    while (TRUE) {
      diffi <- Ek(n, theta_iter) - k
      if (diffi < 0) {
        theta_iter <- theta_iter + 0.1
      } else if (diffi > 0) {
        theta_iter <- theta_iter - 0.1
      }
      if (abs(diffi) < 0.5) {
        break;
      }
    }
  
    theta_iter
  
  },
  ignoreNULL = FALSE
)

renderText({
  paste0("theta ≈ ", round(iterative_theta_data(), 2))
})
```

#### Archaeological Sample Size *p.16-17*

$t_E$ may yield wrong estimates of $θ$ for very large archaeological samples that accumulated over long periods of time. Equation (9) implies that for a given number of variants $k$, $t_E$ will decline as the sample size $n$ increases. Usually $n$ is limited by the population size $N$, but in case of a long-term sample this limit can be exceeded: $n$ can grow beyond $N$ and causes the estimate of $θ$ to be too low. In this case $t_F$ can again be the better function to determine $θ$. Another solution is to look at the difference between both estimators ($t_F - t_E$) as a function of assemblage size. For the application in archaeological contexts it's always important to carefully examine the relationships among $t_F$ and $t_E$ and possible sample size effects.

#### Inferences About Group Size and Innovation Rate *p.17-18*

$θ$ is defined as twice the effective population size times the innovation rate ($2 N_e μ$). The innovation rate $μ$ includes the combined effects of both in situ innovation $v$ and the introduction of novel variants from other groups $m$. If $μ = v + m$, then $N_e μ = N_e v + N_e m$. $v$ should be roughly constant across demes, but $m$ is likely to be more variable in time and space. Under these circumstances, most of the variation in $θ$ associated with $μ$ will be caused by variation in intergroup transmission rates. $θ$ mostly depends on the numver of times local group members learn from members of other groups: $N_e m$. That means that variation in $θ$ is an indicator for the absolute amount of cultural transmission among demes in a geographical region. 
 
### Drift, Intergroup Transmission, and Interassemblage Distance

#### Dynamics of Stylistic Distance between Two Groups *p.21-24* **(10)**

To compare groups and track the cultural transmission we need a simple measure of between-group similarity. One possibility is to look at the squared Euclidian distance $d_{ij}^2$. It's the sum of squared differences in variant frequencies $p$ between two groups $i$ and $j$.  

$$d_{ij}^2 = \sum_{k = 1}^{n} (p_{ik} - p_{jk})^2$$

- $d_{ij}^2$: Squared Euclidian distance between two groups
- $n$: total amount of variants (here not sample size)

```{r echo=FALSE}
inputPanel(
  sliderInput("n_sed_general", label = "n",
               min = 10, max = 100, value = 50, step = 10),
  actionButton("run_sed_general", "Run simulation")
)

sed_general_data <- eventReactive(
  input$run_sed_general, {
  
    # read input
    n <- input$n_sed_general

    # calculate 
    tibble::tibble(
      amount_of_variants = 0:n,
      sed_min = sapply(amount_of_variants, function(x) {
        min(replicate(500, sed(runif(x), runif(x))))
      }),
      sed_max = sapply(amount_of_variants, function(x) {
        max(replicate(500, sed(runif(x), runif(x))))
      }),
      sed_mean = (sed_min + sed_max) / 2
    )
  
  },
  ignoreNULL = FALSE
)

renderPlot({
  sed_general_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = amount_of_variants, ymin = sed_min, ymax = sed_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = amount_of_variants, y = sed_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
})
```

The study of intergroup cultural transmission requires a model setup that contains the effect of drift but also exchange between groups. One promising approach comes from migration matrix models, which in population genetics have proven useful in studying the effects of drift and intergroup genetic transmission on genetic distances among small, localized demes. Such models reveal what happends to variant frequencies in a finite number of demes that are subject to the joint effects of drift, whose strength is controlled by the effective size of each population, and intergroup transmission, ocurring between demes at constant pairwise rates. There is no role role in these models for in situ innovation, but they offer a means of checking the assumption that variation in $θ$ is largely a function of intergroup transmission. 

The following simulation is constructed like the very first one about the effects of drift. Only in this case, there is a set probability, the intergroup transmission rate $m_i$, that the individual contacted is derived from the other group. If $m_i = 0$, both groups act independently, but if it increases they tend to develop roughly alike.

The line chart below the variant frequency area plot shows the distance measure $d_{ij}^2$ calculated for the two groups at the respective point in model time.

$m_i$: intergroup transmission rate

```{r echo=FALSE}
inputPanel(
  sliderInput("k_two_groups", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_two_groups", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mi_two_groups", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  actionButton("run_button_two_groups", "Run simulation")
)

group_drift_simulation_data <- eventReactive(
  input$run_button_group_drift_simulation, {
    
    # run simulation (code in source file)
    group_drift_simulation(
      input$k_two_groups, 
      input$N_two_groups, 
      input$t_two_groups, 
      input$mi_two_groups
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  A <- group_drift_simulation_data() %>%
    ggplot() +
      geom_area(
        aes(x = time, y = individuals_with_variant, fill = variant, group = variant)
      ) +
      geom_line(
        aes(x = time, y = individuals_with_variant, group = variant), 
        position = "stack"
      ) +
      theme_bw() +
      xlab("t") +
      ylab("variants and their occurence in the population [%]") +
      facet_grid(group ~ .)
  
  B <- calculate_sed_for_group_drift_simulation_result(
    group_drift_simulation_data()
  ) %>%
    ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw()  +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
  
  cowplot::plot_grid(A, B, nrow = 2, align = "v", axis = "lr")
})
```

We can run the above simulation many times to see different results random drift can produce. At the beginning the distance between the groups is always zero, because the variants and variant frequencies are equal in both. However, as time passes, the distance increases up to a quasi-stationary equilibrium. The equilibrium is only quasi-stationary because the groups are finite and there is no innovation: if the simulations are continued for a sufficient number of time periods, a single variant is fixed and as a result the between-group distance reverts to zero. The equilibrium holds over the period during which the opposing forces of drift, locally reducing variation within each group, and intergroup transmission, introducing potentially novel variation into each group from the other, are balanced. Later drift globally depletes all variation in both groups.

Higher levels of intergroup transmission $m_i$ will lower the equilibrium level, while lower levels of intergroup transmission raise it. Lower effective sizes $N$ for either or both groups will raise the equilibrium since the effects of drift scale with $N$. The speed with which the equilibrium is achieved depends heavily on the modes of transmission. Horizontal transmission can cause rather fast changes, while vertical and oblique transmission may take centuries. The equilibrium is also approached in case of initially divergent groups with different variants and variant frequencies if there is intergroup transmission among them ($m_i > 0$).

```{r echo=FALSE}
inputPanel(
  sliderInput("k_two_groups_many_runs", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N__two_groups_many_runs", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups_many_runs", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_two_groups_many_runs", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs_two_groups_many_runs", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_two_groups_many_runs", "Run simulation")
)

two_groups_many_runs_data <- eventReactive(
  input$run_button_two_groups_many_runs, {
    
    # run the simulation many times and store results in res_list
    res_list <- list()
    for (i in 1:input$sim_runs) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          input$k_group_2, 
          input$N_group_2, 
          input$t_final_group_2, 
          input$mi_2
        ),
        sim_run = i
      ) 
    }
    
    # rbind individual simulation results into one data.frame
    do.call(rbind, res_list)
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  two_groups_many_runs_data() %>%
    ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed, group = sim_run), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
})
```

#### Stylistic Distances for Multiple Groups *p.24-25* **(11)** **(12)**

$$\mathbf{V}^{(t)} = \sum_{r = 0}^{t - 1} \mathbf{M}^r \mathbf{U}(\mathbf{M}^r)^{\prime}$$

- $\mathbf{M}$: Matrix of intergroup transmission rates
- $\mathbf{V}^{(t)}$: Matrix of variances and covariances
- $r$: Index of the successive time periods
- $\mathbf{U}$ Matrix of reciprocals of the effective population sizes ($1 / N_e$). These are on the diagonal, the rest is 0.
- $(\mathbf{M}^r)^{\prime}$: M transponiert

$$d_{ij}^{2(t)} = v_{ii}^{(t)} + v_{jj}^{(t)} - 2 v_{ij}^{(t)}$$

- $v_{ii}^{(t)}$: Diagonal element of $\mathbf{V}^{(t)}$ -- a variance. The square of of the departure of the variant frequency in the $i$'th deme at time $t$ from its starting frequency when the demes were identical, standardized by the variance of that starting frequency.
- $v_{ij}^{(t)}$: Covariance. The product of the departures of the variant frequencies in each pair of demes i and j, again standardized by the variance of the starting frequency. 

### Woodland Interassemblage Distance

#### Diversity and Distance for Individual Assemblages *p.26-27* **(13)**

$$\bar{d}_{i}^{2} = \sum_{j = 1}^{n} d_{ij}^{2} / (n - 1), i \neq j$$

```{r echo = FALSE}
inputPanel(
  sliderInput("Ne_matrix", label = "Ne",
             min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_matrix", label = "t",
             min = 10, max = 100, value = 20, step = 10),
  actionButton("run_button_matrix_calculation", "Run matrix calculation")
)

matrix_calculation_data <- eventReactive(
  input$run_button_matrix_calculation, {
    Mk <- function(k, mi_3) {
      M <- matrix(data = rep(0, 5^2), nrow = 5, ncol = 5)
      #M[] <- 0.2
      M[1,] <- c(0.4, 0.0, 0.2, 0.0, 0.4)
      M[2,] <- c(0.0, 0.4, 0.2, 0.4, 0.0)
      M[3,] <- c(0.2, 0.2, 0.2, 0.2, 0.2)
      M[4,] <- c(0.2, 0.1, 0.3, 0.2, 0.2)
      M[5,] <- c(0.2, 0.3, 0.1, 0.2, 0.2)
      M
    }
    
    multi_group_matrizes(input$Ne_matrix, input$t_matrix, Mk)
  },
  ignoreNULL = FALSE
)

renderPlot({
  plotlist <- lapply(matrix_calculation_data(), function(x) {
    ggplot(x, aes(x = Var2, y = Var1)) + 
      geom_raster(aes(fill=value)) +
      geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
      scale_y_reverse(sec.axis = dup_axis()) +
      scale_x_continuous(sec.axis = dup_axis()) +
      xlab("group") +
      ylab("group")
  })

  cowplot::plot_grid(
    plotlist = plotlist,
    labels = c("M", "M'", "U", "V", "SED", "MSD"), 
    nrow = 3, ncol = 2
  )
},
height = 1200
)
``` 

Simulation with matrix calculation results

```{r echo = FALSE}
inputPanel(
  sliderInput("k_group_3", label = "k",
               min = 15, max = 25, value = 20, step = 1),
  sliderInput("N_group_3", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_final_group_3", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_3", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs_2", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_group_drift_simulation_iter_2", "Run simulation")
)

group_drift_simulation_data_3 <- eventReactive(
  input$run_button_group_drift_simulation_iter_2, {
    
    k_group_3 <- input$k_group_3 
    N_group_3 <- input$N_group_3 
    t_final_group_3 <- input$t_final_group_3
    mi_3 <- input$mi_3
    sim_runs_2 <- input$sim_runs_2
    
    mixed_list <- list()
    
    res_list <- list()
    for (i in 1:sim_runs_2) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          k_group_3, 
          N_group_3, 
          t_final_group_3, 
          mi_3
        ),
        sim_run = i
      ) 
    }
    
    mixed_list[[1]] <- do.call(rbind, res_list)
    
    Mk_2 <- function(k, mi_3) {
      M <- matrix(data = rep(0, 2^2), nrow = 2, ncol = 2)
      M[1,] <- c(1 - mi_3, mi_3)
      M[2,] <- c(mi_3, 1 - mi_3)
      M
    }
    
    sqe_m <- c() 
    for (t_m in 0:t_final_group_3) {
      #print(multi_group_matrizes(N_group_3, t_m, Mk_2)$longmosed)
      sqe_m[t_m + 1] <- multi_group_matrizes(N_group_3, t_m, Mk_2, mi_3)$longmosed$value[2]
    }
    
    mixed_list[[2]] <- data.frame(t = 0:t_final_group_3, sed = sqe_m)
    
    mixed_list
  },
  ignoreNULL = FALSE
)

renderPlot({
  mixed_list <- group_drift_simulation_data_3()
  
  ggplot() +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
    geom_line(
      data = mixed_list[[1]], 
      aes(x = t, y = sed, group = sim_run), 
      color = "black", size = 1, alpha = 0.3
    ) +
    geom_point(
      data = mixed_list[[1]],
      aes(x = t, y = sed), 
      color = "black", size = 1
    ) +
    geom_line(
      data = mixed_list[[2]], 
      aes(x = t, y = sed), 
      color = "dodgerblue4", size = 2
    ) +
    theme_bw() +
    xlab(latex2exp::TeX("t")) +
    ylab(latex2exp::TeX("d_{ij}^2"))
})
```

### Literature
