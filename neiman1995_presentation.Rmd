---
title: "'Stylistic variation in evolutionary perspective'"
author: "Clemens Schmid"
date: "Juni 2018"
output: 
  ioslides_presentation:
    css: styles_presentation.css
    widescreen: true
    smaller: true
runtime: shiny
bibliography: references.bib
link-citations: true
---

```{r include=FALSE}
# knitr chunk settings
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = FALSE}
# load the packages, that are inconvinient to reference directly via namespace::
library(ggplot2)
library(magrittr)
suppressMessages(library(expm))
# load the functions in the source files
purrr::walk(list.files("./R", full.names = T), function(x) {source(x)})
```

## Disclaimer

*This document visualizes the simulations and the general model functions in Fraser D. Neimans article Stylistic Variation in Evolutionary Perspective: Inferences from Decorative Diversity and Interassemblage Distance in Illinois Woodland Ceramic Assemblages [@neiman_stylistic_1995].*

**Abstract**

> Certain aspects of what archaeologists have traditionally called stylistic variation can be understood as the rresult of the introduction of selectively neutral variation into social-learning populations and the sampling error in the cultural transmission of that variation (drift). Simple mathematical models allow the deduction of expectation for the dynamics of these evolutionary mechanisms as monitored in the archaeological record through assemblage diversity and interassemblage distance. The models are applied to make inferences about the causes of change in decorative diversity and interassemblage distance for Woodland ceramics from Illinois.

# Drift, Innovation and Diversity

## Temporal Dynamics of Drift

**Drift** is sampling error that accompanies all forms of cultural transmission and **causes individual variants to vanish or dominate randomly**. The speed with which the variation is destroyed increases as the population size decreases. 

Mechanics of the following simulation:    
In each time step every individual randomly adopts a variant from somebody else. The probability of getting somebody else's variant is $(N - 1) / N$ while the probability of keeping the own variant is only $1 / N$. 

- $k$: Amount of variants in a population
- $N_e$: Size of the effective population. The effective population consists of the individuals within a population that is actively involved in a cultural transmission process
- $t$: Time / number of iterations

## Temporal Dynamics of Drift

```{r echo=FALSE}
inputPanel(
  sliderInput("k_drift_simulation", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("Ne_drift_simulation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_drift_simulation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  actionButton("run_button_drift_simulation", "Run simulation")
)

drift_simulation_data <- eventReactive(
  input$run_button_drift_simulation, {
    
    # read input
    k <- input$k_drift_simulation
    N <- input$Ne_drift_simulation
    time <- input$t_drift_simulation
    
    # calculate population parameters
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:time
    
    # create initial population
    pop0 <- tibble::tibble(
      time = as.integer(0),
      individual = 1:N,
      variant = rep_len(variants, N)
    )
    
    # list to store population stages over time
    pop_devel <- list()
    pop_devel[[1]] <- pop0
    
    # simulation loop
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]] 
      pop_new$time <- p1 - 1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
      pop_devel[[p1]] <- pop_new
    }
    
    # bind individual population stages into data.frame
    pop_devel_df <- do.call(rbind, pop_devel)
    
    # calculate number of individuals per timestep and variant
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      # complete (expand.grid) to fill gaps in the area plot
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum
  },
  ignoreNULL = FALSE
)

renderPlot({
  
  drift_simulation_data() %>%
    ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab(expression(paste("t"))) +
      ylab("variants and their occurence in the population [%]")
  
})
```

## Homogeneity Under Drift

The theory of neutral alleles allows to describe the **within-population homogeneity $F$** as a function of the effective population size $N_e$. 

$$F_t = \frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}$$

- $F_t$: Within-population homogeneity. Calculated as the probability that two randomly chosen individuals in the population carry variants that are copies of a common antecedent variant at a certain time step

In a given time period the probability of drawing an individual, who learned from the same model as some other randomly selected individual in the previous time period, is $1 / N$. The probability of the opposite is $1 - (1 / N)$. 

- $F_{t - 1}$: Probability that the model of the second individual learned from the same model as the model of the first individual in an earlier time step

As an effect of drift, $F_t$ approaches one as $t$ increases.

## Homogeneity Under Drift

```{r echo=FALSE}
Ft <- function(F0, Ne, time) {
  if(time == 0) { return(F0) }
  1/Ne + (1 - 1/Ne) * Ft(F0, Ne, time - 1)
}

inputPanel(
  sliderInput("F0_homogeneity_drift", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_homogeneity_drift", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_homogeneity_drift", label = "t",
               min = 50, max = 200, value = 100, step = 50)
)

renderPlot({
  
  # read input
  F0 <- input$F0_homogeneity_drift
  Ne <- input$Ne_homogeneity_drift
  time <- input$t_homogeneity_drift
  
  timesteps <- 0:time
  
  # apply function for all timesteps
  Ft_time <- sapply(timesteps, function(x) { Ft(F0, Ne, x) })
  
  data.frame(
    t = timesteps,
    Ft = Ft_time
  ) %>%
    ggplot() +
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(t, Ft), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("F_{t}"))
})
```

## Temporal Dynamics of Drift and Innovation

The effect of **drift** on **homongeneity** shrinks if **innovation** is possible.

Mechanics of the folowing simulation:    
The simulation works like the first one, but now there's a chance of $μ$ for every individual in every time step to create a new variant.

- $μ$: Innovation rate. Probability of the creation of a new variant

The effect of drift is still strongly visible, but with increasing $μ$ it becomes less relevant. New variants can form and replace the dominant one. 

## Temporal Dynamics of Drift and Innovation

```{r echo=FALSE}
inputPanel(
  sliderInput("k_drift_simulation_with_innovation", label = "k for t == 0",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("Ne_drift_simulation_with_innovation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_drift_simulation_with_innovation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_drift_simulation_with_innovation", label = "μ",
               min = 0, max = 0.1, value = 0.01, step = 0.01),
  actionButton("run_button_drift_simulation_with_innovation", "Run simulation")
)

drift_simulation_with_innovation_data <- eventReactive(
  input$run_button_drift_simulation_with_innovation, {
    
    # read input
    k <- input$k_drift_simulation_with_innovation
    N <- input$Ne_drift_simulation_with_innovation
    time <- input$t_drift_simulation_with_innovation
    mu <- input$mu_drift_simulation_with_innovation
  
    # prepare population parameters
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:time
  
    # create starting population
    pop0 <- tibble::tibble(
      time = as.integer(0),
      individual = 1:N,
      variant = rep_len(1:k, N)
    )
  
    # list to store population stages over time
    pop_devel <- list()
    pop_devel[[1]] <- pop0
  
    # simulation loop
    last_variant <- max(pop_devel[[1]]$variant)
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]]
      pop_new$time <- p1 - 1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
  
      # innovation
      innovate_here <- sample(
        c(TRUE, FALSE), 
        length(pop_new$variant), 
        prob = c(mu, 1 - mu), 
        replace = T
      )
      new_variants <- seq(last_variant + 1, last_variant + sum(innovate_here))
      last_variant <- last_variant + sum(innovate_here)
      pop_new$variant[innovate_here] <- new_variants
  
      pop_devel[[p1]] <- pop_new
    }
  
    # bind individual population stages into data.frame
    pop_devel_df <- do.call(rbind, pop_devel)
    
    # calculate number of individuals per timestep and variant
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum
  
  },
  ignoreNULL = FALSE
)

renderPlot({
  drift_simulation_with_innovation_data() %>%
    ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab("t") +
      ylab("variants and their occurence in the population [%]")
})
```

## Homogeneity Under Drift and Innovation

Drift and innovation are opposing forces: **drift increases homogeneity and innovation decreases it**. 

This causes an **equilibrium** after some time steps in the simulation. 

We can incorporate innovation into the calculation of $F$ by modifying equation (1). 

$$F_t = \left(\frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}\right)(1 - μ)^2$$

## Homogeneity Under Drift and Innovation

```{r echo=FALSE}
Ft_innovation <- function(F0, Ne, time, mu) {
  if(time == 0) {return(F0)}
  (1/Ne + (1 - 1/Ne) * Ft_innovation(F0, Ne, time - 1, mu)) * (1 - mu)^2
}

inputPanel(
  sliderInput("F0_homogeneity_drift_with_innovation", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_homogeneity_drift_with_innovation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_homogeneity_drift_with_innovation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_homogeneity_drift_with_innovation", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderPlot({
  
  # read input
  F0 <- input$F0_homogeneity_drift_with_innovation
  Ne <- input$Ne_homogeneity_drift_with_innovation
  mu <- input$mu_homogeneity_drift_with_innovation
  time <- input$t_homogeneity_drift_with_innovation
  
  timesteps <- 0:time
  
  # apply function for every timestep
  Ft_innovation_time <- sapply(timesteps, function(x) {Ft_innovation(F0, Ne, x, mu)})
  
  data.frame(
    t = timesteps,
    Ft = Ft_innovation_time
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(t, Ft), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("F_{t}"))
})
```

## Homogeneity Under Drift and Innovation

$$F_t = \left(\frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}\right)(1 - μ)^2$$

The equilibrium is reached, when $F_t = F_{t-1}$. Setting $F_t = F_{t-1}$ in equation (2) defines $\hat{F}$.

$$\hat{F} = \frac{(1 - μ)^2}{N_e} - (N_e - 1)(1 - μ)^2$$

If we assume $μ$ is quite small we can further simplify this definition.

$$\hat{F} \simeq \frac{1}{2 N_e μ + 1}$$

That means **the homogeneity of neutral variants within a population is inversely proportional to twice the effective population size times the innovation rate**: $2*N_e*μ$. This expression will be called $θ$.

- $θ$: Twice the effective population size times the innovation rate ($2 N_e μ$)

## Homogeneity Under Drift and Innovation

```{r echo=FALSE}
theta <- function(Ne, mu) {
  (2 * Ne * mu)
}

Fhat <- function(theta) {
  1 / (theta + 1)
}

inputPanel(
  sliderInput("Ne_homogeneity_equilibrium", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_homogeneity_equilibrium", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_homogeneity_equilibrium, input$mu_homogeneity_equilibrium))
})

renderPlot({
  Ne <- input$Ne_homogeneity_equilibrium
  mu <- input$mu_homogeneity_equilibrium
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    Fhat = sapply(theta, function(x) {Fhat(x)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, Fhat), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("\\hat{F}"))
})
```

## Homogeneity Under Drift and Innovation

The **homogeneity $\hat{F}$** of a population can also be described as a **function of the relative frequency of the variants in it**: $p$. 

$p_i$ is the relative frequency of the $i$'th variant in the population, so $p$ is a vector of frequencies with the sum one. The probability of choosing a given variant at random is its relative frequency $p_i$, which is also the probability of picking another copy of this same variant on the second try. The probability of getting this variant twice in a row is therefore $p_i^2$. 

The total probability of getting any of the $i = 1$ to $k$ variants twice in a row is the sum of all these probabilities.

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

Mechanics of the following simulation:    
$p$ is randomly drawn some hundred times from a uniform distribution for every value of $k$. The black line shows the mean result for $\hat{F}$ the ribbon the min and max results.

- $p_i$: relative frequency of the $i$'th variant in the population 

## Homogeneity Under Drift and Innovation

```{r echo=FALSE}
Fhat_relative_frequency <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  sum(p^2)
}

inputPanel(
  sliderInput("k_relative_frequency", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_relative_frequency", label = "Number of simulation runs",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_relative_frequency", "Run simulation")
)

relative_frequency_data <- eventReactive(
  input$run_button_relative_frequency, {
  
    # read input  
    number_of_replications <- input$number_of_replications_relative_frequency
    k <- input$k_relative_frequency
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      Fhat_min = sapply(k, function(x) {
        min(replicate(number_of_replications, Fhat_relative_frequency(x)))
      }),
      Fhat_max = sapply(k, function(x) {
        max(replicate(number_of_replications, Fhat_relative_frequency(x)))
      }),
      Fhat_mean = (Fhat_min + Fhat_max) / 2
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  relative_frequency_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = Fhat_min, ymax = Fhat_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = Fhat_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("\\hat{F}"))
})
```

## Diversity

Instead of looking at homogeneity we can also estimate the **diversity inside a population**. One measure of diversity is the **"effective number" of variants $n_e$**, which is the reciprocal of $\hat{F}$. 

$n_e$ scales linearly with $θ$. Larger populations contain more diversity at a given level of innovation. Greater diversity is also expected in populations into which new variants are being introduced at higher rates. 

$$n_e = 2 N_e μ + 1$$

- $n_e$: Effective number of variants

## Diversity

```{r echo=FALSE}
ne <- function(theta) {
  theta + 1
}

inputPanel(
  sliderInput("Ne_diversity_effective_number", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_diversity_effective_number", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_diversity_effective_number, input$mu_diversity_effective_number))
})

renderPlot({
  
  # read input
  Ne <- input$Ne_diversity_effective_number
  mu <- input$mu_diversity_effective_number  
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    ne = sapply(theta, function(x) {ne(x)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, ne), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("n_e"))
})
```

## Diversity

**$θ$ can be estimated empirically by computing the reciprocal of the sum of squares of variant frequencies in a population**. 

$$t_F = \frac{1}{\sum_{i=1}^{k} p^2_i} - 1$$

We can call such estimates $t_F$, to distinguish them from the actual population values and to remind ourselves that they are based on the homogeneity $\hat{F}$ in Equation (5). 

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

With this equation we can get useful insights into variations in $θ$ among groups or demes.

Mechanics of the following simulation:    
$p$ is randomly drawn some hundred times from a uniform distribution for every value of $k$. The black line shows the mean result for $t_F$, the ribbon the min and max results.

- $t_F$: Estimated $θ$ by the sum of squares of variant frequencies

## Diversity

```{r echo=FALSE}
theta_F <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  (1 / sum(p^2)) - 1
}

inputPanel(
  sliderInput("k_reciprocal_relative_frequency", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_reciprocal_relative_frequency", label = "Number of simulation runs",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_reciprocal_relative_frequency", "Run simulation")
)

reciprocal_relative_frequency_data <- eventReactive(
  input$run_button_reciprocal_relative_frequency, {
  
    # read input  
    number_of_replications <- input$number_of_replications_reciprocal_relative_frequency
    k <- input$k_reciprocal_relative_frequency
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      theta_F_min = sapply(k, function(x) {
        min(replicate(number_of_replications, theta_F(x)))
      }),
      theta_F_max = sapply(k, function(x) {
        max(replicate(number_of_replications, theta_F(x)))
      }),
      theta_F_mean = (theta_F_min + theta_F_max) / 2
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  reciprocal_relative_frequency_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = theta_F_min, ymax = theta_F_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = theta_F_mean), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("t_F"))
})
```

# Archaeological Application

## Diversity and Sample Size

$$H = -\sum_{i = 1}^{k} p_i \log(p_i)$$

- $H$: [Shannon's diversity index](http://www.tiem.utk.edu/~gross/bioed/bealsmodules/shannonDI.html)

## Diversity and Sample Size

```{r echo=FALSE}
H <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  -sum(p * log(p))
}

inputPanel(
  sliderInput("k_shannon", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_shannon", label = "Number of simulation runs",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_shannon", "Run simulation")
)

shannon_data <- eventReactive(
  input$run_button_shannon, {
  
    # read input  
    number_of_replications <- input$number_of_replications_shannon
    k <- input$k_shannon
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      H_min = sapply(k, function(x) {
        min(replicate(number_of_replications, H(x)))
      }),
      H_max = sapply(k, function(x) {
        max(replicate(number_of_replications, H(x)))
      }),
      H_mean = (H_min + H_max) / 2
    ) 
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  shannon_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = H_min, ymax = H_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = H_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("H"))
})
```

## Diversity and Sample Size

$$E(k) = \sum_{i = 0}^{n - 1} \frac{θ}{θ + i}$$

- $E(k)$: Expected number of different variants
- $n$: Sample size

## Diversity and Sample Size

```{r echo=FALSE}
Ek <- function(n, theta) {
  ressum <- 0
  for (i in 0:(n-1)) {
    ressum = ressum + (theta / (theta + i))
  }
  return(ressum)
}

inputPanel(
  sliderInput("Ne_expected_variants", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_expected_variants", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01),
  sliderInput("n_expected_variants", label = "n",
               min = 0, max = 100, value = 10, step = 1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_expected_variants, input$mu_expected_variants))
})

renderPlot({
  
  # read input
  Ne <- input$Ne_expected_variants
  mu <- input$mu_expected_variants
  n <- input$n_expected_variants
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    n = rep(n, 101),
    Ek = purrr::map2_dbl(n, theta, function(a, b) {Ek(a, b)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, Ek), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("E(k)"))
})
```

## Diversity and Sample Size

## Diversity and Sample Size

```{r echo=FALSE}
inputPanel(
  sliderInput("n_iterative_theta", label = "n",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("k_iterative_theta", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  actionButton("run_iterative_theta", "Approximate theta")
)

iterative_theta_data <- eventReactive(
  input$run_iterative_theta, {
  
    # read input
    n <- input$n_iterative_theta
    k <- input$k_iterative_theta
    start_theta <- 10
    
    # iterative solving loop
    theta_iter <- start_theta
    while (TRUE) {
      diffi <- Ek(n, theta_iter) - k
      if (diffi < 0) {
        theta_iter <- theta_iter + 0.1
      } else if (diffi > 0) {
        theta_iter <- theta_iter - 0.1
      }
      if (abs(diffi) < 0.5) {
        break;
      }
    }
  
    theta_iter
  
  },
  ignoreNULL = FALSE
)

renderText({
  paste0("theta ≈ ", round(iterative_theta_data(), 2))
})
```

## Archaeological Sample Size

## Inferences About Group Size and Innovation Rate

# Drift, Intergroup Transmission, and Interassemblage Distance

## Dynamics of Stylistic Distance between Two Groups

$$d_{ij}^2 = \sum_{k = 1}^{n} (p_{ik} - p_{jk})^2$$

- $d_{ij}^2$: Squared Euclidean distance between two groups
- $n$: total amount of variants (here not sample size)

## Dynamics of Stylistic Distance between Two Groups

```{r echo=FALSE}
inputPanel(
  sliderInput("n_sed_general", label = "n",
               min = 10, max = 100, value = 50, step = 10),
  actionButton("run_sed_general", "Run simulation")
)

sed_general_data <- eventReactive(
  input$run_sed_general, {
  
    # read input
    n <- input$n_sed_general

    # calculate 
    tibble::tibble(
      amount_of_variants = 0:n,
      sed_min = sapply(amount_of_variants, function(x) {
        min(replicate(500, sed(runif(x), runif(x))))
      }),
      sed_max = sapply(amount_of_variants, function(x) {
        max(replicate(500, sed(runif(x), runif(x))))
      }),
      sed_mean = (sed_min + sed_max) / 2
    )
  
  },
  ignoreNULL = FALSE
)

renderPlot({
  sed_general_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = amount_of_variants, ymin = sed_min, ymax = sed_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = amount_of_variants, y = sed_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
})
```

## Dynamics of Stylistic Distance between Two Groups

## Dynamics of Stylistic Distance between Two Groups

```{r echo=FALSE}
inputPanel(
  sliderInput("k_two_groups", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_two_groups", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mi_two_groups", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  actionButton("run_button_two_groups", "Run simulation")
)

group_drift_simulation_data <- eventReactive(
  input$run_button_group_drift_simulation, {
    
    # run simulation (code in source file)
    group_drift_simulation(
      input$k_two_groups, 
      input$N_two_groups, 
      input$t_two_groups, 
      input$mi_two_groups
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  A <- group_drift_simulation_data() %>%
    ggplot() +
      geom_area(
        aes(x = time, y = individuals_with_variant, fill = variant, group = variant)
      ) +
      geom_line(
        aes(x = time, y = individuals_with_variant, group = variant), 
        position = "stack"
      ) +
      theme_bw() +
      xlab("t") +
      ylab("variants and their occurence in the population [%]") +
      facet_grid(group ~ .)
  
  B <- calculate_sed_for_group_drift_simulation_result(
    group_drift_simulation_data()
  ) %>%
    ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw()  +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
  
  cowplot::plot_grid(A, B, nrow = 2, align = "v", axis = "lr")
})
```

## Dynamics of Stylistic Distance between Two Groups

```{r echo=FALSE}
inputPanel(
  sliderInput("k_two_groups_many_runs", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_two_groups_many_runs", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups_many_runs", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_two_groups_many_runs", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs_two_groups_many_runs", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_two_groups_many_runs", "Run simulation")
)

two_groups_many_runs_data <- eventReactive(
  input$run_button_two_groups_many_runs, {
    
    # run the simulation many times and store results in res_list
    res_list <- list()
    for (i in 1:input$sim_runs_two_groups_many_runs) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          input$k_two_groups_many_runs, 
          input$N_two_groups_many_runs, 
          input$t_two_groups_many_runs, 
          input$mi_two_groups_many_runs
        ),
        sim_run = i
      ) 
    }
    
    # rbind individual simulation results into one data.frame
    do.call(rbind, res_list)
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  two_groups_many_runs_data() %>%
    ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed, group = sim_run), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
})
```

## Stylistic Distances for Multiple Groups

$$\mathbf{V}^{(t)} = \sum_{r = 0}^{t - 1} \mathbf{M}^r \mathbf{U}(\mathbf{M}^r)^{\prime}$$

- $\mathbf{M}$: Matrix of intergroup transmission rates
- $\mathbf{V}^{(t)}$: Matrix of variances and covariances
- $r$: Index of the successive time periods
- $\mathbf{U}$ Matrix of reciprocals of the effective population sizes ($1 / N_e$). These are on the diagonal, the rest is $0$
- $(\mathbf{M}^r)^{\prime}$: M transposed

$$d_{ij}^{2(t)} = v_{ii}^{(t)} + v_{jj}^{(t)} - 2 v_{ij}^{(t)}$$

- $v_{ii}^{(t)}$: Diagonal element of $\mathbf{V}^{(t)}$ -- a variance. The square of of the departure of the variant frequency in the $i$'th deme at time $t$ from its starting frequency when the demes were identical, standardized by the variance of that starting frequency
- $v_{ij}^{(t)}$: Covariance. The product of the departures of the variant frequencies in each pair of demes $i$ and $j$, again standardized by the variance of the starting frequency

## Stylistic Distances for Multiple Groups

```{r echo = FALSE}
inputPanel(
  sliderInput("Ne_matrix", label = "Ne",
             min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_matrix", label = "t",
             min = 10, max = 100, value = 20, step = 10),
  actionButton("run_button_matrix_calculation", "Run matrix calculation")
)

matrix_calculation_data <- eventReactive(
  input$run_button_matrix_calculation, {
    Mk <- function(k, mi_3) {
      M <- matrix(data = rep(0, 5^2), nrow = 5, ncol = 5)
      #M[] <- 0.2
      M[1,] <- c(0.4, 0.0, 0.2, 0.0, 0.4)
      M[2,] <- c(0.0, 0.4, 0.2, 0.4, 0.0)
      M[3,] <- c(0.2, 0.2, 0.2, 0.2, 0.2)
      M[4,] <- c(0.2, 0.1, 0.3, 0.2, 0.2)
      M[5,] <- c(0.2, 0.3, 0.1, 0.2, 0.2)
      M
    }
    
    multi_group_matrizes(input$Ne_matrix, input$t_matrix, Mk)
  },
  ignoreNULL = FALSE
)

renderPlot({
  plotlist <- lapply(matrix_calculation_data(), function(x) {
    ggplot(x, aes(x = Var2, y = Var1)) + 
      geom_raster(aes(fill=value)) +
      geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
      scale_y_reverse(sec.axis = dup_axis()) +
      scale_x_continuous(sec.axis = dup_axis()) +
      xlab("group") +
      ylab("group")
  })

  cowplot::plot_grid(
    plotlist = plotlist,
    labels = c("M", "M'", "U", "V", "SED", "MSD"), 
    nrow = 3, ncol = 2
  )
},
height = 1200
)
``` 

# Woodland Interassemblage Distance

## Trends in Interassemblage Distance

## Diversity and Distance for Individual Assemblages

$$\bar{d}_{i}^{2} = \sum_{j = 1}^{n} d_{ij}^{2} / (n - 1), i \neq j$$

## Diversity and Distance for Individual Assemblages

```{r echo = FALSE}
inputPanel(
  sliderInput("k_two_groups_many_runs_with_msd", label = "k",
               min = 15, max = 25, value = 20, step = 1),
  sliderInput("N_two_groups_many_runs_with_msd", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups_many_runs_with_msd", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_two_groups_many_runs_with_msd", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs_two_groups_many_runs_with_msd", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_two_groups_many_runs_with_msd", "Run simulation")
)

two_groups_many_runs_with_msd_data <- eventReactive(
  input$run_button_two_groups_many_runs_with_msd, {
    
    # read input
    k <- input$k_two_groups_many_runs_with_msd 
    N <- input$N_two_groups_many_runs_with_msd 
    t_final <- input$t_two_groups_many_runs_with_msd
    mi <- input$mi_two_groups_many_runs_with_msd
    sim_runs <- input$sim_runs_two_groups_many_runs_with_msd
    
    mixed_list <- list()
    
    # run group drift simulation
    res_list <- list()
    for (i in 1:sim_runs) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          k, 
          N, 
          t_final, 
          mi
        ),
        sim_run = i
      ) 
    }
    
    mixed_list[[1]] <- do.call(rbind, res_list)
    
    # calculate matrix and mean squared distance
    Mk_msd <- function(k, mi) {
      M <- matrix(data = rep(0, 2^2), nrow = 2, ncol = 2)
      M[1,] <- c(1 - mi, mi)
      M[2,] <- c(mi, 1 - mi)
      M
    }
    
    msd <- c() 
    for (t_m in 0:t_final) {
      msd[t_m + 1] <- multi_group_matrizes(
        N, t_m, Mk_msd, mi
      )$longmosed$value[2]
    }
    
    mixed_list[[2]] <- data.frame(t = 0:t_final, sed = msd)
    
    mixed_list
  },
  ignoreNULL = FALSE
)

renderPlot({
  mixed_list <- two_groups_many_runs_with_msd_data()
  
  ggplot() +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
    geom_line(
      data = mixed_list[[1]], 
      aes(x = t, y = sed, group = sim_run), 
      color = "black", size = 1, alpha = 0.3
    ) +
    geom_point(
      data = mixed_list[[1]],
      aes(x = t, y = sed), 
      color = "black", size = 1
    ) +
    geom_line(
      data = mixed_list[[2]], 
      aes(x = t, y = sed), 
      color = "dodgerblue4", size = 2
    ) +
    theme_bw() +
    xlab(latex2exp::TeX("t")) +
    ylab(latex2exp::TeX("d_{ij}^2"))
})
```

## References
