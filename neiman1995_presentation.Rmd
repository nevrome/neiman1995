---
title: "'Stylistic variation in evolutionary perspective'"
author: "Clemens Schmid"
date: "Juni 2018"
output: 
  ioslides_presentation:
    css: styles_presentation.css
    widescreen: true
    smaller: true
runtime: shiny
bibliography: references.bib
link-citations: true
---

```{r include=FALSE}
# start presentation from console: R -e "rmarkdown::run('~/neomod/neiman1995/neiman1995_presentation.Rmd', shiny_args = list(port = 8241, launch.browser = T))"

# knitr chunk settings
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = FALSE}
# load the packages, that are inconvinient to reference directly via namespace::
library(ggplot2)
library(magrittr)
suppressMessages(library(expm))
# load the functions in the source files
purrr::walk(list.files("./R", full.names = T), function(x) {source(x)})
```

## Disclaimer

*This document visualizes the simulations and the general model functions in Fraser D. Neimans article Stylistic Variation in Evolutionary Perspective: Inferences from Decorative Diversity and Interassemblage Distance in Illinois Woodland Ceramic Assemblages [@neiman_stylistic_1995].*

<iframe src="http://www.jstor.org/stable/282074"></iframe>

# Introduction 

## Introduction: Cultural Evolution

**Cultural Evolution theory**     
The processes of natural development of species through evolution also affect human cultural development.

> Certain aspects of what archaeologists have traditionally called **stylistic variation** can be understood as the result of the introduction of **selectively neutral variation** into **social-learning populations** and the **sampling error** in the cultural transmission of that variation (**drift**). 
> 
> Simple mathematical models allow the deduction of expectation for the dynamics of these evolutionary mechanisms as monitored in the archaeological record through **assemblage diversity** and **interassemblage distance**. 
>
> The models are applied to make inferences about the causes of change in decorative diversity and interassemblage distance for **Woodland ceramics from Illinois**.
>
> -- @neiman_stylistic_1995, Abstract. (boldface and paragraphs in this and in the following citations from me)

## Introduction: Stylistic vs. functional cultural traits

> **Style** denotes those forms that do not have detectable selective values. **Function** is manifest as those forms that directly affect the Darwinian fitness of the populations in which they occur.
>
> [...]
>
> Traits that have discrete selective values over measurable amounts of time should be accountable by natural selection and a set of external conditions. **Traits identified as adaptively neutral will display a very different kind of behavior** because their frequencies in a population are not directly accountable in terms of selection and external contingencies. Their behavior should be more adequately accommodated by **stochastic processes**
>
> -- @dunnell1978style, 199.

\ 

> In a neo-Darwinian framework these definitions imply that **variation in stylistic variant frequencies in time and space** will be affected by a subset of evolutionary forces that introduce selectively neutral cultural variation into populations of social learners, for example, **innovation** and **intergroup transmission** [(**flow**)], and then sort it stochastically (**drift**).
>
> -- @neiman_stylistic_1995, 8.    

\

The main mechanisms of diffusion of neutral variants are **innovation**, **drift** and **flow**.

## Introduction

**Method?**    

> The signal advantage of embedding style in a Darwinian framework is that it **becomes possible to make and evaluate inferences about what happened in history**. These twin goals are accomplished by developing **models of the operation of different evolutionary forces or mechanisms** defined by theory. Models in turn deliver **expectations concerning spatial and temporal distributions** of elements that result from the operation of different mechanisms. Given a suite of measurements of real-world phenomena or statistical summaries of them, we are in a position to make **inferences about the mechanisms that caused observed values**. The inferences can be checked by developing additional models and expectations, based on independent lines of reasoning. Over the long term, the agreement of independent inferences leads to historical knowledge. **Thus while model building is an abstract enterprise, the payoff is fundamentally pragmatic.**
>
> -- @neiman_stylistic_1995, 8.    

\

> The chances of developing a deductively correct answer are increased if we work with **formal models**, capable of representation in either **mathematical formalism** or **computer simulation**, of the evolutionary mechanisms that govern the distribution of selectively neutral forms in time and space.
>
> -- @neiman_stylistic_1995, 9.

# Drift, Innovation and Diversity

## Temporal Dynamics of Drift

**Drift** is sampling error that accompanies all forms of cultural transmission and **causes individual variants to vanish or dominate randomly**. The speed with which the variation is destroyed increases as the population size decreases. 

<span style="color:red">Mechanics of the following simulation: 
In each time step every individual randomly adopts a variant from somebody else. The probability of getting somebody else's variant is $(N - 1) / N$ while the probability of keeping the own variant is only $1 / N$. 
</span>    

- $k$: Amount of variants in a population
- $N_e$: Size of the effective population. The effective population consists of the individuals within a population that is actively involved in a cultural transmission process
- $t$: Time / number of iterations

## Temporal Dynamics of Drift

```{r echo=FALSE}
inputPanel(
  sliderInput("k_drift_simulation", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("Ne_drift_simulation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_drift_simulation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  actionButton("run_button_drift_simulation", "Run simulation")
)

drift_simulation_data <- eventReactive(
  input$run_button_drift_simulation, {
    
    # read input
    k <- input$k_drift_simulation
    N <- input$Ne_drift_simulation
    time <- input$t_drift_simulation
    
    # calculate population parameters
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:time
    
    # create initial population
    pop0 <- tibble::tibble(
      time = as.integer(0),
      individual = 1:N,
      variant = rep_len(variants, N)
    )
    
    # list to store population stages over time
    pop_devel <- list()
    pop_devel[[1]] <- pop0
    
    # simulation loop
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]] 
      pop_new$time <- p1 - 1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
      pop_devel[[p1]] <- pop_new
    }
    
    # bind individual population stages into data.frame
    pop_devel_df <- do.call(rbind, pop_devel)
    
    # calculate number of individuals per timestep and variant
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      # complete (expand.grid) to fill gaps in the area plot
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum
  },
  ignoreNULL = FALSE
)

renderPlot({
  
  drift_simulation_data() %>%
    ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab(expression(paste("t"))) +
      ylab("variants and their occurence in the population [%]")
  
})
```

## Homogeneity Under Drift

The theory of neutral alleles allows to describe the **within-population homogeneity $F$** as a function of the effective population size $N_e$. 

$$F_t = \frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}$$

- $F_t$: Within-population homogeneity. Calculated as the probability that two randomly chosen individuals in the population carry variants that are copies of a common antecedent variant at a certain time step

In a given time period the probability of drawing an individual, who learned from the same model as some other randomly selected individual in the previous time period, is $1 / N$. The probability of the opposite is $1 - (1 / N)$. 

- $F_{t - 1}$: Probability that the model of the second individual learned from the same model as the model of the first individual in an earlier time step

As an effect of drift, $F_t$ approaches one as $t$ increases.

## Homogeneity Under Drift

```{r echo=FALSE}
Ft <- function(F0, Ne, time) {
  if(time == 0) { return(F0) }
  1/Ne + (1 - 1/Ne) * Ft(F0, Ne, time - 1)
}

inputPanel(
  sliderInput("F0_homogeneity_drift", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_homogeneity_drift", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_homogeneity_drift", label = "t",
               min = 50, max = 200, value = 100, step = 50)
)

renderPlot({
  
  # read input
  F0 <- input$F0_homogeneity_drift
  Ne <- input$Ne_homogeneity_drift
  time <- input$t_homogeneity_drift
  
  timesteps <- 0:time
  
  # apply function for all timesteps
  Ft_time <- sapply(timesteps, function(x) { Ft(F0, Ne, x) })
  
  data.frame(
    t = timesteps,
    Ft = Ft_time
  ) %>%
    ggplot() +
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(t, Ft), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("F_{t}"))
})
```

## Temporal Dynamics of Drift and Innovation

The effect of **drift** on **homongeneity** shrinks if **innovation** is possible.

<span style="color:red">Mechanics of the following simulation:      
The simulation works like the first one, but now there's a chance of $\mu$ for every individual in every time step to create a new variant.
</span> 

- $\mu$: Innovation rate. Probability of the creation of a new variant

The effect of drift is still strongly visible, but with increasing $\mu$ it becomes less relevant. New variants can form and replace the dominant one. 

## Temporal Dynamics of Drift and Innovation

```{r echo=FALSE}
inputPanel(
  sliderInput("k_drift_simulation_with_innovation", label = "k for t == 0",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("Ne_drift_simulation_with_innovation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_drift_simulation_with_innovation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_drift_simulation_with_innovation", label = "μ",
               min = 0, max = 0.1, value = 0.01, step = 0.01),
  actionButton("run_button_drift_simulation_with_innovation", "Run simulation")
)

drift_simulation_with_innovation_data <- eventReactive(
  input$run_button_drift_simulation_with_innovation, {
    
    # read input
    k <- input$k_drift_simulation_with_innovation
    N <- input$Ne_drift_simulation_with_innovation
    time <- input$t_drift_simulation_with_innovation
    mu <- input$mu_drift_simulation_with_innovation
  
    # prepare population parameters
    population <- 1:N
    variants <- 1:k
    timesteps <- 2:time
  
    # create starting population
    pop0 <- tibble::tibble(
      time = as.integer(0),
      individual = 1:N,
      variant = rep_len(1:k, N)
    )
  
    # list to store population stages over time
    pop_devel <- list()
    pop_devel[[1]] <- pop0
  
    # simulation loop
    last_variant <- max(pop_devel[[1]]$variant)
    for (p1 in timesteps) {
      pop_new <- pop_devel[[p1 - 1]]
      pop_new$time <- p1 - 1
      pop_new$variant <- sample(pop_new$variant, length(pop_new$variant), replace = T)
  
      # innovation
      innovate_here <- sample(
        c(TRUE, FALSE), 
        length(pop_new$variant), 
        prob = c(mu, 1 - mu), 
        replace = T
      )
      new_variants <- seq(last_variant + 1, last_variant + sum(innovate_here))
      last_variant <- last_variant + sum(innovate_here)
      pop_new$variant[innovate_here] <- new_variants
  
      pop_devel[[p1]] <- pop_new
    }
  
    # bind individual population stages into data.frame
    pop_devel_df <- do.call(rbind, pop_devel)
    
    # calculate number of individuals per timestep and variant
    pop_devel_sum <- pop_devel_df %>%
      dplyr::group_by(
        time, variant
      ) %>%
      dplyr::summarise(
        individuals_with_variant = n()
      ) %>%
      dplyr::ungroup() %>%
      tidyr::complete(
        time, 
        variant, 
        fill = list(individuals_with_variant = as.integer(0))
      )
    
    pop_devel_sum
  
  },
  ignoreNULL = FALSE
)

renderPlot({
  drift_simulation_with_innovation_data() %>%
    ggplot() +
      geom_area(aes(x = time, y = individuals_with_variant, fill = variant, group = variant)) +
      geom_line(aes(x = time, y = individuals_with_variant, group = variant), position = "stack") +
      theme_bw() +
      xlab("t") +
      ylab("variants and their occurence in the population [%]")
})
```

## Homogeneity Under Drift and Innovation

Drift and innovation are opposing forces: **drift increases homogeneity and innovation decreases it**. 

This causes an **equilibrium** after some time steps in the simulation. 

We can incorporate innovation into the calculation of $F$ by modifying equation (1). 

$$F_t = \left(\frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}\right)(1 - \mu)^2$$

## Homogeneity Under Drift and Innovation

```{r echo=FALSE}
Ft_innovation <- function(F0, Ne, time, mu) {
  if(time == 0) {return(F0)}
  (1/Ne + (1 - 1/Ne) * Ft_innovation(F0, Ne, time - 1, mu)) * (1 - mu)^2
}

inputPanel(
  sliderInput("F0_homogeneity_drift_with_innovation", label = "F0 (Ft for t == 0)",
               min = 0, max = 1, value = 0.5, step = 0.05),
  sliderInput("Ne_homogeneity_drift_with_innovation", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_homogeneity_drift_with_innovation", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mu_homogeneity_drift_with_innovation", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderPlot({
  
  # read input
  F0 <- input$F0_homogeneity_drift_with_innovation
  Ne <- input$Ne_homogeneity_drift_with_innovation
  mu <- input$mu_homogeneity_drift_with_innovation
  time <- input$t_homogeneity_drift_with_innovation
  
  timesteps <- 0:time
  
  # apply function for every timestep
  Ft_innovation_time <- sapply(timesteps, function(x) {Ft_innovation(F0, Ne, x, mu)})
  
  data.frame(
    t = timesteps,
    Ft = Ft_innovation_time
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(t, Ft), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("F_{t}"))
})
```

## Homogeneity Under Drift and Innovation

$$F_t = \left(\frac{1}{N_e} + \left(1 - \frac{1}{N_e} \right) F_{t-1}\right)(1 - \mu)^2$$

The equilibrium is reached, when $F_t = F_{t-1}$. Setting $F_t = F_{t-1}$ in equation (2) defines $\hat{F}$.

$$\hat{F} = \frac{(1 - \mu)^2}{N_e} - (N_e - 1)(1 - \mu)^2$$

If we assume $\mu$ is quite small we can further simplify this definition.

$$\hat{F} \simeq \frac{1}{2 N_e \mu + 1}$$

That means **the homogeneity of neutral variants within a population is inversely proportional to twice the effective population size times the innovation rate**: $2*N_e*\mu$. This expression will be called $\theta$.

- $\theta$: Twice the effective population size times the innovation rate ($2 N_e \mu$)

## Homogeneity Under Drift and Innovation

```{r echo=FALSE}
theta <- function(Ne, mu) {
  (2 * Ne * mu)
}

Fhat <- function(theta) {
  1 / (theta + 1)
}

inputPanel(
  sliderInput("Ne_homogeneity_equilibrium", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_homogeneity_equilibrium", label = "μ",
               min = 0, max = 1, value = 0.1, step = 0.1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_homogeneity_equilibrium, input$mu_homogeneity_equilibrium))
})

renderPlot({
  Ne <- input$Ne_homogeneity_equilibrium
  mu <- input$mu_homogeneity_equilibrium
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    Fhat = sapply(theta, function(x) {Fhat(x)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, Fhat), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("\\hat{F}"))
})
```

## Homogeneity Under Drift and Innovation

The **homogeneity $\hat{F}$** of a population can also be described as a **function of the relative frequency of the variants in it**: $p$. 

$p_i$ is the relative frequency of the $i$'th variant in the population, so $p$ is a vector of frequencies with the sum one. The probability of choosing a given variant at random is its relative frequency $p_i$, which is also the probability of picking another copy of this same variant on the second try. The probability of getting this variant twice in a row is therefore $p_i^2$. 

The total probability of getting any of the $i = 1$ to $k$ variants twice in a row is the sum of all these probabilities.

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

<span style="color:red">Mechanics of the following simulation:    
$p$ is randomly drawn some hundred times from a uniform distribution for every value of $k$. The black line shows the mean result for $\hat{F}$ the ribbon the min and max results.
</span>

- $p_i$: relative frequency of the $i$'th variant in the population 

## Homogeneity Under Drift and Innovation

```{r echo=FALSE}
Fhat_relative_frequency <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  sum(p^2)
}

inputPanel(
  sliderInput("k_relative_frequency", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_relative_frequency", label = "Number of simulation runs",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_relative_frequency", "Run simulation")
)

relative_frequency_data <- eventReactive(
  input$run_button_relative_frequency, {
  
    # read input  
    number_of_replications <- input$number_of_replications_relative_frequency
    k <- input$k_relative_frequency
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      Fhat_min = sapply(k, function(x) {
        min(replicate(number_of_replications, Fhat_relative_frequency(x)))
      }),
      Fhat_max = sapply(k, function(x) {
        max(replicate(number_of_replications, Fhat_relative_frequency(x)))
      }),
      Fhat_mean = (Fhat_min + Fhat_max) / 2
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  relative_frequency_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 1), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = Fhat_min, ymax = Fhat_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = Fhat_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("\\hat{F}"))
})
```

## Diversity

Instead of looking at homogeneity we can also estimate the **diversity inside a population**. One measure of diversity is the **"effective number" of variants $n_e$**, which is the reciprocal of $\hat{F}$. 

$n_e$ scales linearly with $\theta$. Larger populations contain more diversity at a given level of innovation. Greater diversity is also expected in populations into which new variants are being introduced at higher rates. 

$$n_e = 2 N_e \mu + 1$$

- $n_e$: Effective number of variants

## Diversity

```{r echo=FALSE}
ne <- function(theta) {
  theta + 1
}

inputPanel(
  sliderInput("Ne_diversity_effective_number", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_diversity_effective_number", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_diversity_effective_number, input$mu_diversity_effective_number))
})

renderPlot({
  
  # read input
  Ne <- input$Ne_diversity_effective_number
  mu <- input$mu_diversity_effective_number  
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    ne = sapply(theta, function(x) {ne(x)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, ne), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("n_e"))
})
```

## Diversity

**$\theta$ can be estimated empirically by computing the reciprocal of the sum of squares of variant frequencies in a population**. 

$$t_F = \frac{1}{\sum_{i=1}^{k} p^2_i} - 1$$

We can call such estimates $t_F$, to distinguish them from the actual population values and to remind ourselves that they are based on the homogeneity $\hat{F}$ in Equation (5). 

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

With this equation we can get useful insights into variations in $\theta$ among groups or demes.

<span style="color:red">Mechanics of the following simulation:    
$p$ is randomly drawn some hundred times from a uniform distribution for every value of $k$. The black line shows the mean result for $t_F$, the ribbon the min and max results.
</span>

- $t_F$: Estimated $\theta$ by the sum of squares of variant frequencies

## Diversity

```{r echo=FALSE}
theta_F <- function(amount_of_variants) {
  p <- runif(amount_of_variants)
  p <- p / sum(p)
  (1 / sum(p^2)) - 1
}

inputPanel(
  sliderInput("k_reciprocal_relative_frequency", label = "k",
               min = 50, max = 150, value = 100, step = 10),
  sliderInput("number_of_replications_reciprocal_relative_frequency", label = "Number of simulation runs",
               min = 100, max = 1000, value = 500, step = 100),
  actionButton("run_button_reciprocal_relative_frequency", "Run simulation")
)

reciprocal_relative_frequency_data <- eventReactive(
  input$run_button_reciprocal_relative_frequency, {
  
    # read input  
    number_of_replications <- input$number_of_replications_reciprocal_relative_frequency
    k <- input$k_reciprocal_relative_frequency
    
    # calculate Fhat
    tibble::tibble(
      k = 0:k,
      theta_F_min = sapply(k, function(x) {
        min(replicate(number_of_replications, theta_F(x)))
      }),
      theta_F_max = sapply(k, function(x) {
        max(replicate(number_of_replications, theta_F(x)))
      }),
      theta_F_mean = (theta_F_min + theta_F_max) / 2
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  reciprocal_relative_frequency_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = k, ymin = theta_F_min, ymax = theta_F_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = k, y = theta_F_mean), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("t_F"))
})
```

# Archaeological Application

## Diversity and Sample Size

The **frequency of variants** in a population of social learners is not equal to the **frequency preserved and documented** in the **archaeological assemblage**. Under appropriate taphonomic circumstances, however, they are surprisingly similar. 

Another problem arises because we try to estimate diversity only on the basis of a **sample derived from a population**. The equations (5) and (7) are similar to the Shannon-Weaver information statistic, which is very sensitive to sample-size variation.

$$\hat{F} = \sum_{i=1}^{k} p^2_i$$

$$t_F = \frac{1}{\sum_{i=1}^{k} p^2_i} - 1$$

$$H = -\sum_{i = 1}^{k} p_i \log(p_i)$$

- $H$: [Shannon's diversity index](http://www.tiem.utk.edu/~gross/bioed/bealsmodules/shannonDI.html)

## Diversity and Sample Size

$\theta$ is related to the sum of squared variant frequencies in a population, so it should be possible to **predict for a given value of $\theta$ how many variants occur with certain frequencies**. 
 
$$t_F = \frac{1}{\sum_{i=1}^{k} p^2_i} - 1$$

When $\theta$ is low ($\theta \ll 1$), we should expect that most of the time, a population will be dominated by a few variants, with other variants at low frequencies. When $\theta$ is high ($\theta \gg 1$), we are more likely to see a large number of variants at low to moderate frequencies. 

If the variants are selectively neutral, the expected number of different variants $k$ found in a sample drawn from a population is a function of it's sample size $n$ and $\theta$ value. The number of variants will be larger when either $\theta$ or $n$ are large.

$$E(k) = \sum_{i = 0}^{n - 1} \frac{\theta}{\theta + i}$$

- $E(k)$: Expected number of different variants
- $n$: Sample size

## Diversity and Sample Size

```{r echo=FALSE}
Ek <- function(n, theta) {
  ressum <- 0
  for (i in 0:(n-1)) {
    ressum = ressum + (theta / (theta + i))
  }
  return(ressum)
}

inputPanel(
  sliderInput("Ne_expected_variants", label = "Ne",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("mu_expected_variants", label = "μ",
               min = 0, max = 1, value = 0.01, step = 0.01),
  sliderInput("n_expected_variants", label = "n",
               min = 0, max = 100, value = 10, step = 1)
)

renderText({
  paste0("1 * theta = ", theta(input$Ne_expected_variants, input$mu_expected_variants))
})

renderPlot({
  
  # read input
  Ne <- input$Ne_expected_variants
  mu <- input$mu_expected_variants
  n <- input$n_expected_variants
  
  tibble::tibble(
    theta = 0:100 * theta(Ne, mu),
    n = rep(n, 101),
    Ek = purrr::map2_dbl(n, theta, function(a, b) {Ek(a, b)})
  ) %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_line(aes(theta, Ek), size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("θ")) +
      ylab(latex2exp::TeX("E(k)"))
})
```

## Diversity and Sample Size

This could be used to produce a **maximum likelihood estimate of $\theta$**, that is the value of $\theta$ that maximizes the chances of drawing the observed number of variants $k$ in a sample of the size $n$. 

Unfortunately it doesn't have an analytic solution, but we can still use it to estimate $\theta$ iteratively by changing its value until $E(k)$ equals the observed number of variants. 

The following applet allows to solve (9) for theta approximately. It starts at $\theta = 10$, changes it in steps of $0.1$ and stops when $|E(k) - k| < 0.5$.

We call the result of doing so $t_E$. Both $t_E$ and $t_F$ offer us special statistical summaries of assemblage diversity, but there are theoretical reasons to prefer $t_E$ if $n$ and $k$ (and not just $p$) are known. 

## Diversity and Sample Size

```{r echo=FALSE}
inputPanel(
  sliderInput("n_iterative_theta", label = "n",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("k_iterative_theta", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  actionButton("run_iterative_theta", "Approximate theta")
)

iterative_theta_data <- eventReactive(
  input$run_iterative_theta, {
  
    # read input
    n <- input$n_iterative_theta
    k <- input$k_iterative_theta
    start_theta <- 10
    
    # iterative solving loop
    theta_iter <- start_theta
    while (TRUE) {
      diffi <- Ek(n, theta_iter) - k
      if (diffi < 0) {
        theta_iter <- theta_iter + 0.1
      } else if (diffi > 0) {
        theta_iter <- theta_iter - 0.1
      }
      if (abs(diffi) < 0.5) {
        break;
      }
    }
  
    theta_iter
  
  },
  ignoreNULL = FALSE
)

renderText({
  paste0("theta ≈ ", round(iterative_theta_data(), 2))
})
```

## Archaeological Sample Size

$t_E$ may yield wrong estimates of $\theta$ for very large archaeological samples that accumulated over long periods of time.

Equation (9) implies that for a given number of variants $k$, $t_E$ will decline as the sample size $n$ increases. Usually $n$ is limited by the population size $N$, but in case of a long-term sample this limit can be exceeded: $n$ can grow beyond $N$ and causes the estimate of $\theta$ to be too low. 

In this case $t_F$ can again be the better function to determine $\theta$. Another solution is to look at the difference between both estimators ($t_F - t_E$) as a function of assemblage size. For the application in archaeological contexts it's always important to carefully examine the relationships among $t_F$ and $t_E$ and possible sample size effects.

## Inferences About Group Size and Innovation Rate

$\theta$ is defined as twice the effective population size times the innovation rate ($2 N_e \mu$). 

The innovation rate $\mu$ includes the combined effects of both in situ innovation $v$ and the introduction of novel variants from other groups $m$. If $\mu = v + m$, then $N_e \mu = N_e v + N_e m$. 

$v$ should be roughly constant across demes, but $m$ is likely to be more variable in time and space. Under these circumstances, most of the variation in $\theta$ associated with $\mu$ will be caused by variation in intergroup transmission rates. 

$\theta$ mostly depends on the number of times local group members learn from members of other groups: $N_e m$. That means that variation in $\theta$ is an indicator for the absolute amount of cultural transmission among demes in a geographical region. 

# Drift, Intergroup Transmission, and Interassemblage Distance

## Dynamics of Stylistic Distance between Two Groups

To compare groups and track the cultural transmission we need a simple **measure of between-group similarity**. One possibility is to look at the **squared Euclidean distance $d_{ij}^2$**. It's the sum of squared differences in variant frequencies $p$ between two groups $i$ and $j$. 

$$d_{ij}^2 = \sum_{k = 1}^{n} (p_{ik} - p_{jk})^2$$

- $d_{ij}^2$: Squared Euclidean distance between two groups
- $n$: total amount of variants (here not sample size)

## Dynamics of Stylistic Distance between Two Groups

```{r echo=FALSE}
inputPanel(
  sliderInput("n_sed_general", label = "n",
               min = 10, max = 100, value = 50, step = 10),
  actionButton("run_sed_general", "Run simulation")
)

sed_general_data <- eventReactive(
  input$run_sed_general, {
  
    # read input
    n <- input$n_sed_general

    # calculate 
    tibble::tibble(
      amount_of_variants = 0:n,
      sed_min = sapply(amount_of_variants, function(x) {
        min(replicate(500, sed(runif(x), runif(x))))
      }),
      sed_max = sapply(amount_of_variants, function(x) {
        max(replicate(500, sed(runif(x), runif(x))))
      }),
      sed_mean = (sed_min + sed_max) / 2
    )
  
  },
  ignoreNULL = FALSE
)

renderPlot({
  sed_general_data() %>%
    ggplot() +    
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_ribbon(
        aes(x = amount_of_variants, ymin = sed_min, ymax = sed_max), 
        fill = "deepskyblue", alpha = 0.5
      ) +
      geom_line(aes(x = amount_of_variants, y = sed_mean), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("k")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
})
```

## Dynamics of Stylistic Distance between Two Groups

The study of intergroup cultural transmission requires a model setup that contains the effect of drift but also exchange between groups. One promising approach comes from **migration matrix models**, which in population genetics have proven useful in studying the effects of drift and intergroup genetic transmission on genetic distances among small, localized demes. 

Such models reveal what happens to variant frequencies in a finite number of demes that are subject to the joint effects of drift, whose strength is controlled by the effective size of each population, and intergroup transmission, occurring between demes at constant pairwise rates. 

There is no role in these models for in situ innovation, but they offer a means of checking the assumption that variation in $\theta$ is largely a function of intergroup transmission. 

<span style="color:red">Mechanics of the following simulation:  
This simulation is constructed like the very first one about the effects of drift. Only in this case, there is a set probability, the intergroup transmission rate $m_i$, that the individual contacted is derived from the other group. If $m_i = 0$, both groups act independently, but if it increases they tend to develop roughly alike.

The line chart below the variant frequency area plot shows the distance measure $d_{ij}^2$ calculated for the two groups at the respective point in model time.
</span>

$m_i$: intergroup transmission rate

## Dynamics of Stylistic Distance between Two Groups

```{r echo=FALSE}
inputPanel(
  sliderInput("k_two_groups", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_two_groups", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups", label = "t",
               min = 50, max = 200, value = 100, step = 50),
  sliderInput("mi_two_groups", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  actionButton("run_button_two_groups", "Run simulation")
)

group_drift_simulation_data <- eventReactive(
  input$run_button_group_drift_simulation, {
    
    # run simulation (code in source file)
    group_drift_simulation(
      input$k_two_groups, 
      input$N_two_groups, 
      input$t_two_groups, 
      input$mi_two_groups
    )
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  A <- group_drift_simulation_data() %>%
    ggplot() +
      geom_area(
        aes(x = time, y = individuals_with_variant, fill = variant, group = variant)
      ) +
      geom_line(
        aes(x = time, y = individuals_with_variant, group = variant), 
        position = "stack"
      ) +
      theme_bw() +
      xlab("t") +
      ylab("variants and their occurence in the population [%]") +
      facet_grid(group ~ .)
  
  B <- calculate_sed_for_group_drift_simulation_result(
    group_drift_simulation_data()
  ) %>%
    ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw()  +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
  
  cowplot::plot_grid(A, B, nrow = 2, align = "v", axis = "lr")
})
```

## Dynamics of Stylistic Distance between Two Groups

We can run the above simulation many times to see different results random drift can produce. At the beginning the distance between the groups is always zero, because the variants and variant frequencies are equal in both. However, as time passes, the distance increases up to a quasi-stationary equilibrium. The equilibrium is only quasi-stationary because the groups are finite and there is no innovation: if the simulations are continued for a sufficient number of time periods, a single variant is fixed and as a result the between-group distance reverts to zero. The equilibrium holds over the period during which the opposing forces of drift, locally reducing variation within each group, and intergroup transmission, introducing potentially novel variation into each group from the other, are balanced. Later drift globally depletes all variation in both groups.

Higher levels of intergroup transmission $m_i$ will lower the equilibrium level, while lower levels of intergroup transmission raise it. Lower effective sizes $N$ for either or both groups will raise the equilibrium since the effects of drift scale with $N$. The speed with which the equilibrium is achieved depends heavily on the modes of transmission. Horizontal transmission can cause rather fast changes, while vertical and oblique transmission may take centuries. The equilibrium is also approached in case of initially divergent groups with different variants and variant frequencies if there is intergroup transmission among them ($m_i > 0$).

## Dynamics of Stylistic Distance between Two Groups

```{r echo=FALSE}
inputPanel(
  sliderInput("k_two_groups_many_runs", label = "k",
               min = 5, max = 15, value = 10, step = 1),
  sliderInput("N_two_groups_many_runs", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups_many_runs", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_two_groups_many_runs", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs_two_groups_many_runs", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_two_groups_many_runs", "Run simulation")
)

two_groups_many_runs_data <- eventReactive(
  input$run_button_two_groups_many_runs, {
    
    # run the simulation many times and store results in res_list
    res_list <- list()
    for (i in 1:input$sim_runs_two_groups_many_runs) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          input$k_two_groups_many_runs, 
          input$N_two_groups_many_runs, 
          input$t_two_groups_many_runs, 
          input$mi_two_groups_many_runs
        ),
        sim_run = i
      ) 
    }
    
    # rbind individual simulation results into one data.frame
    do.call(rbind, res_list)
    
  },
  ignoreNULL = FALSE
)

renderPlot({
  two_groups_many_runs_data() %>%
    ggplot() +
      geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
      geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
      geom_line(aes(x = t, y = sed, group = sim_run), color = "black", size = 1, alpha = 0.3) +
      geom_point(aes(x = t, y = sed), color = "black", size = 1) +
      theme_bw() +
      xlab(latex2exp::TeX("t")) +
      ylab(latex2exp::TeX("d_{ij}^2"))
})
```

## Stylistic Distances for Multiple Groups

The real world is better represented in terms of more than two groups learning from another. The multi-group case can be described in a matrix based model. The matrix $\mathbf{M}$ contains the intergroup transmission rates $m_{ij}$ that give the proportion of the $i$'th deme that learned from the $j$'th deme. The diagonal elements of $\mathbf{M}$ are the proportion of each deme that learned from its own members. The matrix $\mathbf{U}$ contains the reciprocals of the effective population sizes $1 / N_e$ of each group on its diagonal and $0$'s elsewhere. 

In this setup all groups initially have the same variant frequencies. This means that the expected frequencies for each group in any time period are identical and equal to the starting frequency. Drift-driven departures from this expectation for a given deme can be characterized analytically in terms of variance. Since there are multiple demes in the system, their joint evolution must be handled in terms of a matrix of variances and covariances: $\mathbf{V}$. Diagonal elements in $\mathbf{V}$ contain variances: the square of the departure of the variant frequency in the respective deme at time $t$ from the situation at the starting time. The other elements are covariances: the product of the departures of the variant frequencies in each pair of demes. 

$$\mathbf{V}^{(t)} = \sum_{r = 0}^{t - 1} \mathbf{M}^r \mathbf{U}(\mathbf{M}^r)^{\prime}$$

- $\mathbf{M}$: Matrix of intergroup transmission rates
- $\mathbf{V}^{(t)}$: Matrix of variances and covariances
- $r$: Index of the successive time periods
- $\mathbf{U}$ Matrix of reciprocals of the effective population sizes ($1 / N_e$). These are on the diagonal, the rest is $0$
- $(\mathbf{M}^r)^{\prime}$: M transposed

Equation (11) says that in the first time period, the covariance between two groups is a function of the sum of products of the intergroup transmission rates from all groups to those two groups and the reciprocal of their two effective population sizes. In later time periods, as individuals who learned from non-group members are in turn distributed among the other groups, the intergroup transmission rates from each group to *all* the others assumes increasing importance. The resulting cumulative effect of the indirect movement of variants among groups is handled by successively powering the intergroup transmission matrix.

The magnitude of the covariance between two groups will scale inversely with their sizes $N$ and positively with the intergroup transmission rates $m$. High levels of intergroup transmission will mean that whatever departures from the initial frequency occur, they will be similar and in the same direction, hence the covariance between the groups will be high. On the other hand, if either or both group sizes are low, causing drift to play a stronger role, variant frequencies are less likely to depart from initial frequencies in a similar fashion. The covariances will be low.

The matrix of variances and covariances $\mathbf{V}$ can be converted to a matrix of squared Euclidean distances $d_{ij}^{2}$ (or $\mathbf{SED}$).

$$d_{ij}^{2(t)} = v_{ii}^{(t)} + v_{jj}^{(t)} - 2 v_{ij}^{(t)}$$

- $v_{ii}^{(t)}$: Diagonal element of $\mathbf{V}^{(t)}$ -- a variance. The square of of the departure of the variant frequency in the $i$'th deme at time $t$ from its starting frequency when the demes were identical, standardized by the variance of that starting frequency
- $v_{ij}^{(t)}$: Covariance. The product of the departures of the variant frequencies in each pair of demes $i$ and $j$, again standardized by the variance of the starting frequency

## Stylistic Distances for Multiple Groups

```{r echo = FALSE}
inputPanel(
  sliderInput("Ne_matrix", label = "Ne",
             min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_matrix", label = "t",
             min = 10, max = 100, value = 20, step = 10),
  actionButton("run_button_matrix_calculation", "Run matrix calculation")
)

matrix_calculation_data <- eventReactive(
  input$run_button_matrix_calculation, {
    Mk <- function(k, mi_3) {
      M <- matrix(data = rep(0, 5^2), nrow = 5, ncol = 5)
      #M[] <- 0.2
      M[1,] <- c(0.4, 0.0, 0.2, 0.0, 0.4)
      M[2,] <- c(0.0, 0.4, 0.2, 0.4, 0.0)
      M[3,] <- c(0.2, 0.2, 0.2, 0.2, 0.2)
      M[4,] <- c(0.2, 0.1, 0.3, 0.2, 0.2)
      M[5,] <- c(0.2, 0.3, 0.1, 0.2, 0.2)
      M
    }
    
    multi_group_matrizes(input$Ne_matrix, input$t_matrix, Mk)
  },
  ignoreNULL = FALSE
)

renderPlot({
  plotlist <- lapply(matrix_calculation_data(), function(x) {
    ggplot(x, aes(x = Var2, y = Var1)) + 
      geom_raster(aes(fill=value)) +
      geom_text(aes(x = Var2, y = Var1, label = round(value, 3)), color = "white", size = 5) +
      scale_y_reverse(sec.axis = dup_axis()) +
      scale_x_continuous(sec.axis = dup_axis()) +
      xlab("group") +
      ylab("group")
  })

  cowplot::plot_grid(
    plotlist = plotlist,
    labels = c("M", "M'", "U", "V", "SED", "MSD"), 
    nrow = 3, ncol = 2
  )
},
height = 1200
)
``` 

# Woodland Interassemblage Distance

## Trends in Interassemblage Distance

The migration matrix approach can be applied to cultural transmission contexts by computing a matrix of squared Euclidean distances $\mathbf{SED}$ between the groups for each of the variants. We expect to find that the overall level of differentiation among groups, as measured by the mean of the squared Euclidean distances $\mathbf{MSD}$, is the mirror image of our estimates of $\theta$.

## Diversity and Distance for Individual Assemblages

The mean of the squared Euclidean distance $\bar{d}_{i}^{2}$ (or $MSD$) can be calculated with (13). 

$$\bar{d}_{i}^{2} = \sum_{j = 1}^{n} d_{ij}^{2} / (n - 1), i \neq j$$

## Diversity and Distance for Individual Assemblages

```{r echo = FALSE}
inputPanel(
  sliderInput("k_two_groups_many_runs_with_msd", label = "k",
               min = 15, max = 25, value = 20, step = 1),
  sliderInput("N_two_groups_many_runs_with_msd", label = "N",
               min = 10, max = 100, value = 20, step = 10),
  sliderInput("t_two_groups_many_runs_with_msd", label = "t",
               min = 20, max = 200, value = 20, step = 20),
  sliderInput("mi_two_groups_many_runs_with_msd", label = "mi",
               min = 0, max = 1, value = 0.1, step = 0.01),
  sliderInput("sim_runs_two_groups_many_runs_with_msd", label = "Number of simulation runs",
               min = 1, max = 100, value = 20, step = 1),
  actionButton("run_button_two_groups_many_runs_with_msd", "Run simulation")
)

two_groups_many_runs_with_msd_data <- eventReactive(
  input$run_button_two_groups_many_runs_with_msd, {
    
    # read input
    k <- input$k_two_groups_many_runs_with_msd 
    N <- input$N_two_groups_many_runs_with_msd 
    t_final <- input$t_two_groups_many_runs_with_msd
    mi <- input$mi_two_groups_many_runs_with_msd
    sim_runs <- input$sim_runs_two_groups_many_runs_with_msd
    
    mixed_list <- list()
    
    # run group drift simulation
    res_list <- list()
    for (i in 1:sim_runs) {
      res_list[[i]] <- calculate_sed_for_group_drift_simulation_result(
        group_drift_simulation(
          k, 
          N, 
          t_final, 
          mi
        ),
        sim_run = i
      ) 
    }
    
    mixed_list[[1]] <- do.call(rbind, res_list)
    
    # calculate matrix and mean squared distance
    Mk_msd <- function(k, mi) {
      M <- matrix(data = rep(0, 2^2), nrow = 2, ncol = 2)
      M[1,] <- c(1 - mi, mi)
      M[2,] <- c(mi, 1 - mi)
      M
    }
    
    msd <- c() 
    for (t_m in 0:t_final) {
      msd[t_m + 1] <- multi_group_matrizes(
        N, t_m, Mk_msd, mi
      )$longmosed$value[2]
    }
    
    mixed_list[[2]] <- data.frame(t = 0:t_final, sed = msd)
    
    mixed_list
  },
  ignoreNULL = FALSE
)

renderPlot({
  mixed_list <- two_groups_many_runs_with_msd_data()
  
  ggplot() +
    geom_hline(aes(yintercept = 0), color = "dodgerblue4") +
    geom_hline(aes(yintercept = 2), color = "dodgerblue4") +
    geom_line(
      data = mixed_list[[1]], 
      aes(x = t, y = sed, group = sim_run), 
      color = "black", size = 1, alpha = 0.3
    ) +
    geom_point(
      data = mixed_list[[1]],
      aes(x = t, y = sed), 
      color = "black", size = 1
    ) +
    geom_line(
      data = mixed_list[[2]], 
      aes(x = t, y = sed), 
      color = "dodgerblue4", size = 2
    ) +
    theme_bw() +
    xlab(latex2exp::TeX("t")) +
    ylab(latex2exp::TeX("d_{ij}^2"))
})
```

## References
